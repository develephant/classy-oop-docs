{
    "docs": [
        {
            "location": "/",
            "text": "Simple Object-Oriented Programming (OOP) for Corona\n\n\n\nThe \nClassy OOP\n plugin enables you to build out your \nCorona\n projects using lightweight classes and subclasses all wrapped up in a simple to use API.\n\n\nBasic Class\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nage\n)\n\n  \nself\n.\nage\n \n=\n \nage\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetAge\n()\n\n  \nreturn\n \nself\n.\nage\n\n\nend\n\n\n\n--instances\n\n\nlocal\n \np1\n \n=\n \nPerson\n:\nnew\n(\n26\n)\n\n\nlocal\n \np2\n \n=\n \nPerson\n:\nnew\n(\n45\n)\n\n\n\nprint\n(\np1\n:\ngetAge\n())\n \n--> 26\n\n\nprint\n(\np2\n:\ngetAge\n())\n \n--> 45",
            "title": "Introduction"
        },
        {
            "location": "/#basic-class",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( age ) \n   self . age   =   age  end  function   Person : getAge () \n   return   self . age  end  --instances  local   p1   =   Person : new ( 26 )  local   p2   =   Person : new ( 45 )  print ( p1 : getAge ())   --> 26  print ( p2 : getAge ())   --> 45",
            "title": "Basic Class"
        },
        {
            "location": "/setup/",
            "text": "Get the Plugin\n\n\nIf you don't already have it, get the \nClassy OOP\n plugin from the \nCorona Marketplace\n.\n\n\nEnable the Plugin\n\n\nEnable the plugin by adding an entry to the \nplugins\n table of your projects \nbuild.settings\n file:\n\n\nsettings =\n{\n    plugins =\n    {\n        [\"plugin.classy\"] =\n        {\n            publisherId = \"com.develephant\"\n        },\n    },\n}\n\n\n\n\n\nRequire the Plugin\n\n\nIn your code file make sure to \nrequire\n the plugin.\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n\n\n\nYou're ready to start building using OOP! Move on the \nUsage\n section to learn more.",
            "title": "Setup"
        },
        {
            "location": "/setup/#get-the-plugin",
            "text": "If you don't already have it, get the  Classy OOP  plugin from the  Corona Marketplace .",
            "title": "Get the Plugin"
        },
        {
            "location": "/setup/#enable-the-plugin",
            "text": "Enable the plugin by adding an entry to the  plugins  table of your projects  build.settings  file:  settings =\n{\n    plugins =\n    {\n        [\"plugin.classy\"] =\n        {\n            publisherId = \"com.develephant\"\n        },\n    },\n}",
            "title": "Enable the Plugin"
        },
        {
            "location": "/setup/#require-the-plugin",
            "text": "In your code file make sure to  require  the plugin.  local   Classy   =   require ( \"plugin.classy\" )   You're ready to start building using OOP! Move on the  Usage  section to learn more.",
            "title": "Require the Plugin"
        },
        {
            "location": "/classy/",
            "text": "Before using \nClassy\n you must \nrequire\n the plugin in your code file:\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n\n\n\nClassy\n\n\ncreate\n\n\nCreate a new base class. See also \nClasses\n in the \nUsage\n guide.\n\n\nClassy\n.\ncreate\n(\nclassName\n[,\n \ndefaults\n])\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nType\n\n\nRequired\n\n\n\n\n\n\n\n\n\n\nclassName\n\n\nThe name of the class.\n\n\nString\n\n\nY\n\n\n\n\n\n\ndefaults\n\n\nA key/value table of default properties.\n\n\nTable\n\n\nN\n\n\n\n\n\n\n\n\nReturns\n\n\nA new base class.\n\n\nExample\n\n\nBasic\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\n\n\n\n\nDefaults\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n,\n \n{\n \nage\n \n=\n \n18\n \n})\n\n\n\n\n\n\n\n\nisClass\n\n\nUtility function to check if an object is a base class or subclass.\n\n\nClassy\n.\nisClass\n(\nobject\n)\n\n\n\n\n\n\nReturns\n\n\nA \nBoolean\n value.\n\n\nExample\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\n\nprint\n(\nClassy\n.\nisClass\n(\nPerson\n))\n \n--> true\n\n\n\n\n\n\n\n\nisInstance\n\n\nUtility function to check if an object is an instance of a class or subclass.\n\n\nClassy\n.\nisInstance\n(\nobject\n)\n\n\n\n\n\n\nReturns\n\n\nA \nBoolean\n value.\n\n\nExample\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n()\n\n\n\nprint\n(\nClassy\n.\nisInstance\n(\nperson\n))\n \n--> true\n\n\n\n\n\n\n\n\nClasses\n\n\nconstructor\n\n\nAn optional constructor function that is called when creating new instances of a class (or subclass).\n\n\n<\nclassName\n>\n:\nconstructor\n([\nargs\n])\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nType\n\n\nRequired\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nCommon delimited set of arguments to be consumed when a new instance of the class (or subclass) is created. See \nnew\n.\n\n\nVarious\n\n\nN\n\n\n\n\n\n\n\n\nReturns\n\n\nThis method has no return value.\n\n\nExample\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n,\n \nage\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n  \nself\n.\nage\n \n=\n \nage\n\n\nend\n\n\n\n\n\n\nNotes\n\n\n\n\nThe passed arguments can be of any Lua type.\n\n\n\n\n\n\nextends\n\n\nCreates a \nsubclass\n of a base class (or subclass). See also \nSubclasses\n in the \nUsage\n guide.\n\n\n<\nclassName\n>\n:\nextends\n(\nsubclassName\n[,\n \ndefaults\n])\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nType\n\n\nRequired\n\n\n\n\n\n\n\n\n\n\nsubclassName\n\n\nThe name of the subclass.\n\n\nString\n\n\nY\n\n\n\n\n\n\ndefaults\n\n\nA key/value table of default properties.\n\n\nTable\n\n\nN\n\n\n\n\n\n\n\n\nReturns\n\n\nA new subclass of the class.\n\n\nExample\n\n\nBasic\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n)\n\n\n\n\n\n\nDefaults\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n,\n \n{\n \ntitle\n \n=\n \n\"The Big Cheese\"\n \n})\n\n\n\n\n\n\nNotes\n\n\n\n\nSubclasses can use the \nconstructor\n method.\n\n\nYou can use \nextends\n to subclass a subclass.\n\n\nSyntactically this method can be read as \"Boss extends Person\".\n\n\n\n\n\n\nsuper\n\n\nAccess the super class, which is the class (or subclass) parent. See also \nSubclasses\n in the \nUsage\n guide.\n\n\n \nsuper\n is a property, not a method\n.\n\n\n--Call parent methods\n\n\n<\nclassName\n>\n.\nsuper\n.\n<\nclassMethod\n>\n(\nself\n,\n \n[\nargs\n])\n\n\n\n\n\n\nNotes\n\n\n\n\nTo call a \nsuper\n (parent) method you must use dot (\n.\n) syntax, and pass a reference of \nself\n as the first parameter.\n\n\n\n\nInstances\n\n\nnew\n\n\nCreate a new instance of a class or subclass. See also \nInstances\n in the \nUsage\n guide.\n\n\n<\nclassName\n>\n:\nnew\n([\nargs\n])\n\n\n\n\n\n\nArguments\n\n\n\n\n\n\n\n\nName\n\n\nDescription\n\n\nType\n\n\nRequired\n\n\n\n\n\n\n\n\n\n\nargs\n\n\nCommon delimited set of arguments to pass to the class (or subclass) constructor method, if one exists. See \nconstructor\n.\n\n\nVarious\n\n\nN\n\n\n\n\n\n\n\n\nReturns\n\n\nA new instance of the class or subclass.\n\n\nExample\n\n\nBasic\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n()\n\n\n\n\n\n\nArguments\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n(\n\"Tina\"\n,\n \n23\n)\n\n\n\n\n\n\nNotes\n\n\n\n\nThe passed arguments can be of any Lua type.\n\n\n\n\nUtilities\n\n\nThe following methods are called directly on an object using colon (\n:\n) syntax.\n\n\ninstanceOf\n\n\nA utility method to check if an instance is an instance of a specific class or subclass.\n\n\n<\ninstance\n>\n:\ninstanceOf\n(\n<\nClass\n>\n)\n\n\n\n\n\n\nReturns\n\n\nA \nBoolean\n value.\n\n\nExample\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n()\n\n\n\nprint\n(\nperson\n:\ninstanceOf\n(\nPerson\n))\n \n--> true\n\n\n\n\n\n\n\n\nsubclassOf\n\n\nA utility method to check if a subclass is a subclass of a specific class.\n\n\n<\nSubclass\n>\n:\nsubclassOf\n(\n<\nClass\n>\n)\n\n\n\n\n\n\nReturns\n\n\nA \nBoolean\n value.\n\n\nExample\n\n\nlocal\n \nWand\n \n=\n \nWeapon\n:\nextends\n(\n\"Wand\"\n)\n\n\n\nprint\n(\nWand\n:\nsubclassOf\n(\nWeapon\n))\n \n--> true\n\n\n\n\n\n\n\n\nclassOf\n\n\nA utility method to check if a subclass is derived from a specific class.\n\n\n<\nClass\n>\n:\nclassOf\n(\n<\nSubclass\n>\n)\n\n\n\n\n\n\nReturns\n\n\nA \nBoolean\n value.\n\n\nExample\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nlocal\n \nManager\n \n=\n \nPerson\n:\nextends\n(\n\"Manager\"\n)\n\n\n\nprint\n(\nPerson\n:\nclassOf\n(\nManager\n))\n \n--> true\n\n\n\n\n\n\nNotes\n\n\nSyntactically this method can be read in reverse as in \"is Manager a class of Person\".",
            "title": "API"
        },
        {
            "location": "/classy/#classy",
            "text": "",
            "title": "Classy"
        },
        {
            "location": "/classy/#create",
            "text": "Create a new base class. See also  Classes  in the  Usage  guide.  Classy . create ( className [,   defaults ])   Arguments     Name  Description  Type  Required      className  The name of the class.  String  Y    defaults  A key/value table of default properties.  Table  N     Returns  A new base class.  Example  Basic  local   Person   =   Classy . create ( \"Person\" )   Defaults  local   Person   =   Classy . create ( \"Person\" ,   {   age   =   18   })",
            "title": "create"
        },
        {
            "location": "/classy/#isclass",
            "text": "Utility function to check if an object is a base class or subclass.  Classy . isClass ( object )   Returns  A  Boolean  value.  Example  local   Person   =   Classy . create ( \"Person\" )  print ( Classy . isClass ( Person ))   --> true",
            "title": "isClass"
        },
        {
            "location": "/classy/#isinstance",
            "text": "Utility function to check if an object is an instance of a class or subclass.  Classy . isInstance ( object )   Returns  A  Boolean  value.  Example  local   person   =   Person : new ()  print ( Classy . isInstance ( person ))   --> true",
            "title": "isInstance"
        },
        {
            "location": "/classy/#classes",
            "text": "",
            "title": "Classes"
        },
        {
            "location": "/classy/#constructor",
            "text": "An optional constructor function that is called when creating new instances of a class (or subclass).  < className > : constructor ([ args ])   Arguments     Name  Description  Type  Required      args  Common delimited set of arguments to be consumed when a new instance of the class (or subclass) is created. See  new .  Various  N     Returns  This method has no return value.  Example  function   Person : constructor ( name ,   age ) \n   self . name   =   name \n   self . age   =   age  end   Notes   The passed arguments can be of any Lua type.",
            "title": "constructor"
        },
        {
            "location": "/classy/#extends",
            "text": "Creates a  subclass  of a base class (or subclass). See also  Subclasses  in the  Usage  guide.  < className > : extends ( subclassName [,   defaults ])   Arguments     Name  Description  Type  Required      subclassName  The name of the subclass.  String  Y    defaults  A key/value table of default properties.  Table  N     Returns  A new subclass of the class.  Example  Basic  local   Boss   =   Person : extends ( \"Boss\" )   Defaults  local   Boss   =   Person : extends ( \"Boss\" ,   {   title   =   \"The Big Cheese\"   })   Notes   Subclasses can use the  constructor  method.  You can use  extends  to subclass a subclass.  Syntactically this method can be read as \"Boss extends Person\".",
            "title": "extends"
        },
        {
            "location": "/classy/#super",
            "text": "Access the super class, which is the class (or subclass) parent. See also  Subclasses  in the  Usage  guide.    super  is a property, not a method .  --Call parent methods  < className > . super . < classMethod > ( self ,   [ args ])   Notes   To call a  super  (parent) method you must use dot ( . ) syntax, and pass a reference of  self  as the first parameter.",
            "title": "super"
        },
        {
            "location": "/classy/#instances",
            "text": "",
            "title": "Instances"
        },
        {
            "location": "/classy/#new",
            "text": "Create a new instance of a class or subclass. See also  Instances  in the  Usage  guide.  < className > : new ([ args ])   Arguments     Name  Description  Type  Required      args  Common delimited set of arguments to pass to the class (or subclass) constructor method, if one exists. See  constructor .  Various  N     Returns  A new instance of the class or subclass.  Example  Basic  local   person   =   Person : new ()   Arguments  local   person   =   Person : new ( \"Tina\" ,   23 )   Notes   The passed arguments can be of any Lua type.",
            "title": "new"
        },
        {
            "location": "/classy/#utilities",
            "text": "The following methods are called directly on an object using colon ( : ) syntax.",
            "title": "Utilities"
        },
        {
            "location": "/classy/#instanceof",
            "text": "A utility method to check if an instance is an instance of a specific class or subclass.  < instance > : instanceOf ( < Class > )   Returns  A  Boolean  value.  Example  local   person   =   Person : new ()  print ( person : instanceOf ( Person ))   --> true",
            "title": "instanceOf"
        },
        {
            "location": "/classy/#subclassof",
            "text": "A utility method to check if a subclass is a subclass of a specific class.  < Subclass > : subclassOf ( < Class > )   Returns  A  Boolean  value.  Example  local   Wand   =   Weapon : extends ( \"Wand\" )  print ( Wand : subclassOf ( Weapon ))   --> true",
            "title": "subclassOf"
        },
        {
            "location": "/classy/#classof",
            "text": "A utility method to check if a subclass is derived from a specific class.  < Class > : classOf ( < Subclass > )   Returns  A  Boolean  value.  Example  local   Person   =   Classy . create ( \"Person\" )  local   Manager   =   Person : extends ( \"Manager\" )  print ( Person : classOf ( Manager ))   --> true   Notes  Syntactically this method can be read in reverse as in \"is Manager a class of Person\".",
            "title": "classOf"
        },
        {
            "location": "/usage/class/",
            "text": "Classes are the template by which you create \ninstances\n. Classes can also be \nsubclassed\n, allowing you to extend (reuse) functionality of an existing class. This concept of extending classes and creating instances is the driving force behind OOP practices.\n\n\nDiscussion\n\n\nConventions\n\n\nGenerally a class name will be represented as a capitalized string identifier. For example \"Person\" is a good class identifier.\n\n\nOrganization\n\n\nYou should generally create a single Lua file for each class or subclass you wish to create, using the class indentifier as the file name. For example, a \"Person\" class should be stored in a file named \nPerson.lua\n.\n\n\nHow you organize classes is left to personal preference, but a good practice is to keep your classes in a \"classes\" directory, and \nrequire\n them as needed.\n\n\nFor example, your file tree might look like the following:\n\n\nproject\n  classes/\n    Person.lua\n  main.lua\n\n\n\n\n\nClass Creation\n\n\nA base class is created using the \nClassy\n \ncreate\n method. You can optionally add an \nconstructor\n function if you plan on passing arguments to your class when creating instances.\n\n\nSee the \nSubclasses\n section for details on creating a subclass.\n\n\nA Class File\n\n\nA class file simply consists of the class template, which is then returned at the end of the file.\n\n\nExample\n\n\nclasses/Person.lua\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--#########################################################\n\n\n--# Person Class\n\n\n--#########################################################\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\nreturn\n \nPerson\n\n\n\n\n\n\nYou can then \nrequire\n this class wherever you need it.\n\n\nExample\n\n\nmain.lua\n\n\nlocal\n \nPerson\n \n=\n \nrequire\n(\n\"classes.Person\"\n)\n\n\n\n--create instance\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n(\n\"Marla\"\n)\n\n\n--use instance\n\n\nprint\n(\nperson\n:\ngetName\n())\n \n--> Marla\n\n\n\n\n\n\nSee the \nSubclasses\n section for information on how to set up your subclass files. See the \nInstances\n section for more information on using instances.\n\n\nClass Examples\n\n\nBasic Class\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \np1\n \n=\n \nPerson\n:\nnew\n()\n\n\np1\n.\nage\n \n=\n \n26\n\n\n\nlocal\n \np2\n \n=\n \nPerson\n:\nnew\n()\n\n\np2\n.\nage\n \n=\n \n45\n\n\n\nprint\n(\np1\n.\nage\n)\n \n--> 26\n\n\nprint\n(\np2\n.\nage\n)\n \n--> 45\n\n\n\n\n\n\nClass with Defaults\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n,\n \n{\n \nage\n \n=\n \n23\n \n})\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n()\n\n\nprint\n(\nperson\n.\nage\n)\n \n--> 23 (default)\n\n\n\n\n\n\nClass with Constructor\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nage\n)\n\n  \nself\n.\nage\n  \n=\n \nage\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \np1\n \n=\n \nPerson\n:\nnew\n(\n23\n)\n\n\nprint\n(\np1\n.\nage\n)\n \n--> 23\n\n\n\n\n\n\nClass with Constructor and Defaults\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n,\n \n{\n \nage\n \n=\n \n23\n \n})\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nage\n)\n\n  \nself\n.\nage\n  \n=\n \nage\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \np1\n \n=\n \nPerson\n:\nnew\n()\n\n\nprint\n(\np1\n.\nage\n)\n \n--> 23 (default)\n\n\n\nlocal\n \np2\n \n=\n \nPerson\n:\nnew\n(\n45\n)\n\n\nprint\n(\np2\n.\nage\n)\n \n--> 45\n\n\n\n\n\n\nClass with Methods\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \np1\n \n=\n \nPerson\n:\nnew\n(\n\"Tim\"\n)\n\n\nlocal\n \np2\n \n=\n \nPerson\n:\nnew\n(\n\"Jane\"\n)\n\n\n\nprint\n(\np1\n:\ngetName\n())\n \n--> Tim\n\n\nprint\n(\np2\n:\ngetName\n())\n \n--> Jame",
            "title": "Classes"
        },
        {
            "location": "/usage/class/#discussion",
            "text": "",
            "title": "Discussion"
        },
        {
            "location": "/usage/class/#conventions",
            "text": "Generally a class name will be represented as a capitalized string identifier. For example \"Person\" is a good class identifier.",
            "title": "Conventions"
        },
        {
            "location": "/usage/class/#organization",
            "text": "You should generally create a single Lua file for each class or subclass you wish to create, using the class indentifier as the file name. For example, a \"Person\" class should be stored in a file named  Person.lua .  How you organize classes is left to personal preference, but a good practice is to keep your classes in a \"classes\" directory, and  require  them as needed.  For example, your file tree might look like the following:  project\n  classes/\n    Person.lua\n  main.lua",
            "title": "Organization"
        },
        {
            "location": "/usage/class/#class-creation",
            "text": "A base class is created using the  Classy   create  method. You can optionally add an  constructor  function if you plan on passing arguments to your class when creating instances.  See the  Subclasses  section for details on creating a subclass.",
            "title": "Class Creation"
        },
        {
            "location": "/usage/class/#a-class-file",
            "text": "A class file simply consists of the class template, which is then returned at the end of the file.  Example  classes/Person.lua  local   Classy   =   require ( \"plugin.classy\" )  --#########################################################  --# Person Class  --#########################################################  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ) \n   self . name   =   name  end  function   Person : getName () \n   return   self . name  end  return   Person   You can then  require  this class wherever you need it.  Example  main.lua  local   Person   =   require ( \"classes.Person\" )  --create instance  local   person   =   Person : new ( \"Marla\" )  --use instance  print ( person : getName ())   --> Marla   See the  Subclasses  section for information on how to set up your subclass files. See the  Instances  section for more information on using instances.",
            "title": "A Class File"
        },
        {
            "location": "/usage/class/#class-examples",
            "text": "",
            "title": "Class Examples"
        },
        {
            "location": "/usage/class/#basic-class",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --class  local   Person   =   Classy . create ( \"Person\" )  --#########################################################  --# Instance Examples  local   p1   =   Person : new ()  p1 . age   =   26  local   p2   =   Person : new ()  p2 . age   =   45  print ( p1 . age )   --> 26  print ( p2 . age )   --> 45",
            "title": "Basic Class"
        },
        {
            "location": "/usage/class/#class-with-defaults",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --class  local   Person   =   Classy . create ( \"Person\" ,   {   age   =   23   })  --#########################################################  --# Instance Examples  local   person   =   Person : new ()  print ( person . age )   --> 23 (default)",
            "title": "Class with Defaults"
        },
        {
            "location": "/usage/class/#class-with-constructor",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( age ) \n   self . age    =   age  end  --#########################################################  --# Instance Examples  local   p1   =   Person : new ( 23 )  print ( p1 . age )   --> 23",
            "title": "Class with Constructor"
        },
        {
            "location": "/usage/class/#class-with-constructor-and-defaults",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --class  local   Person   =   Classy . create ( \"Person\" ,   {   age   =   23   })  function   Person : constructor ( age ) \n   self . age    =   age  end  --#########################################################  --# Instance Examples  local   p1   =   Person : new ()  print ( p1 . age )   --> 23 (default)  local   p2   =   Person : new ( 45 )  print ( p2 . age )   --> 45",
            "title": "Class with Constructor and Defaults"
        },
        {
            "location": "/usage/class/#class-with-methods",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ) \n   self . name   =   name  end  function   Person : getName () \n   return   self . name  end  --#########################################################  --# Instance Examples  local   p1   =   Person : new ( \"Tim\" )  local   p2   =   Person : new ( \"Jane\" )  print ( p1 : getName ())   --> Tim  print ( p2 : getName ())   --> Jame",
            "title": "Class with Methods"
        },
        {
            "location": "/usage/subclass/",
            "text": "Subclasses allow you to \"extend\" the functionality of another \nclass\n (or subclass). Once you create a subclass, you gain all the methods and properties of the class you are subclassing and can then build upon it.\n\n\nThis is a powerful concept in OOP which spares you from rewriting functionality, and instead adding only what you need to an existing class.\n\n\nDiscussion\n\n\nConventions\n\n\nGenerally a subclass name will be represented as a capitalized string identifier. For example \"Boss\" is a good subclass identifier.\n\n\nSubclass Creation\n\n\nSubclasses are created using the \nextends\n method on the class you want to extend.\n\n\nSuper Constructor\n\n\nWhen creating a subclass, we are inheriting functionality from another class. The class being subclassed is the \"parent\" or \"superclass\" of the subclass.\n\n\nWhen we need access to the \"parent\", we use the \nsuper\n property of the subclass. This is used most often when a subclass contains a \nconstructor\n function to pass information up the inheritance chain.\n\n\nThe following example and discussion demonstrates how this works:\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--Person base class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\n--Manager subclass\n\n\nlocal\n \nManager\n \n=\n \nPerson\n:\nextends\n(\n\"Manager\"\n)\n\n\nfunction\n \nManager\n:\nconstructor\n(\nname\n)\n\n  \n--# Pass up the arguments to the parent class\n\n  \nManager\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n)\n\n\nend\n\n\n\n--Boss subclass\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n)\n\n\nfunction\n \nBoss\n:\nconstructor\n(\nname\n)\n\n  \n--# Pass up the arguments to the parent class\n\n  \nBoss\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n)\n\n\nend\n\n\n\n--instances\n\n\nlocal\n \nmanager\n \n=\n \nManager\n:\nnew\n(\n\"Jenny\"\n)\n\n\nprint\n(\nmanager\n:\ngetName\n())\n \n--> Jenny\n\n\n\nlocal\n \nboss\n \n=\n \nBoss\n:\nnew\n(\n\"Jorge\"\n)\n\n\nprint\n(\nboss\n:\ngetName\n())\n \n--> Jorge\n\n\n\n\n\n\nIn the example above, we use a \nPerson\n class to represent a person. We have only defined a \nname\n property and \ngetName\n method, but could add many others. All sublasses of a Person class \"type\" will have a \nname\n associated with them.\n\n\nWe only want to store the \nname\n property once. We also have access to the \nPerson:getName()\n method, which again, we only want to define once for any subclass of a Person \"type\".\n\n\nOur subclasses represent a \nManager\n and \nBoss\n, which both fit under the Person \"type\" and so we don't need to recreate the \nname\n property or \ngetName\n method, which lives in the Person base class.\n\n\nBut, we do need to make sure the Person base class gets the \nname\n property, so we call the \n<Class>.super.constructor\n function in each of our subclasses \nconstructor\n functions, which passes the name up. \n\n\nBecause both the Manager and Boss are subclasses of the Person class, their \nsuper\n property points to the Person base class. You can use the \nsuper\n property to call any methods or manipulate any properties on the \"parent\" class. This is shown in some examples below.\n\n\n \nPay attention to the signature of the \nsuper.constructor\n function. You need to make sure you pass a reference of \nself\n to it, along with any additional arguments, and use only dot (\n.\n) syntax:\n\n\n<\nClass\n>\n.\nsuper\n.\nconstructor\n(\nself\n[,\n \nargs\n])\n\n\n\n\n\n\nSubclass Examples\n\n\nBasic SubClass\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--base class (with defaults)\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n,\n \n{\n \nage\n \n=\n \n24\n \n})\n\n\n\nfunction\n \nPerson\n:\ngetAge\n()\n\n  \nreturn\n \nself\n.\nage\n\n\nend\n\n\n\n--subclass\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n)\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nboss\n \n=\n \nBoss\n:\nnew\n()\n\n\n\nprint\n(\nboss\n:\ngetAge\n())\n \n--> 24 (Person default)\n\n\n\n\n\n\nSubclass with Defaults\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--base class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n,\n \n{\n \nname\n \n=\n \n\"Unknown\"\n,\n \nage\n \n=\n \n25\n \n})\n\n\n\nfunction\n \nPerson\n:\ngetAge\n()\n\n  \nreturn\n \nself\n.\nage\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\n--subclass\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n,\n \n{\n \ntitle\n \n=\n \n\"Big Cheese\"\n \n})\n\n\n\nfunction\n \nBoss\n:\ngetTitle\n()\n\n  \nreturn\n \nself\n.\ntitle\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nboss\n \n=\n \nBoss\n:\nnew\n()\n\n\n\nprint\n(\nboss\n:\ngetTitle\n())\n \n--> Big Cheese\n\n\nprint\n(\nboss\n:\ngetName\n())\n \n--> Unknown\n\n\nprint\n(\nboss\n:\ngetAge\n())\n \n--> 25\n\n\n\n\n\n\nSubClass with Constructor\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--base class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n,\n \nage\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n  \nself\n.\nage\n \n=\n \nage\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetAge\n()\n\n  \nreturn\n \nself\n.\nage\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\n--subclass\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n)\n\n\nfunction\n \nBoss\n:\nconstructor\n(\nname\n,\n \nage\n,\n \ntitle\n)\n\n  \nBoss\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nage\n)\n\n\n  \nself\n.\ntitle\n \n=\n \ntitle\n\n\nend\n\n\n\nfunction\n \nBoss\n:\ngetTitle\n()\n\n  \nreturn\n \nself\n.\ntitle\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nboss\n \n=\n \nBoss\n:\nnew\n(\n\"Mary\"\n,\n \n42\n,\n \n\"Big Cheese\"\n)\n\n\n\nprint\n(\nboss\n:\ngetName\n())\n \n--> Mary\n\n\nprint\n(\nboss\n:\ngetAge\n())\n \n--> 42\n\n\nprint\n(\nboss\n:\ngetTitle\n())\n \n--> Big Cheese\n\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n(\n\"Jane\"\n,\n \n32\n)\n\n\n\nprint\n(\nperson\n:\ngetName\n())\n \n--> Jane\n\n\nprint\n(\nperson\n:\ngetTitle\n())\n \n-- error (method not on Person class)\n\n\n\n\n\n\nSubclass Method Override\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--base class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n\nend\n\n\n\nfunction\n \nPerson\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\n--subclass\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n)\n\n\nfunction\n \nBoss\n:\nconstructor\n(\nname\n)\n\n  \nBoss\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n)\n\n\nend\n\n\n\n--override\n\n\nfunction\n \nBoss\n:\ngetName\n()\n\n  \nreturn\n \n\"I'm the boss, \"\n..\nself\n.\nname\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nperson\n \n=\n \nPerson\n:\nnew\n(\n\"Jimmy\"\n)\n\n\nlocal\n \nboss\n \n=\n \nBoss\n:\nnew\n(\n\"Poppy\"\n)\n\n\n\nprint\n(\nperson\n:\ngetName\n())\n \n--> Jimmy\n\n\nprint\n(\nboss\n:\ngetName\n())\n \n--> I'm the boss, Poppy\n\n\n\n\n\n\nSubclass Method Override with Super Call\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--base class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n\nend\n\n\n\nfunction\n \nPerson\n:\nprintName\n()\n\n  \nprint\n(\n\"My name is \"\n..\nself\n.\nname\n)\n\n\nend\n\n\n\n--sub class (with defaults)\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n,\n \n{\n \ntitle\n \n=\n \n\"The Main Taco\"\n \n})\n\n\nfunction\n \nBoss\n:\nconstructor\n(\nname\n)\n\n  \nBoss\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n)\n\n\nend\n\n\n\n--override\n\n\nfunction\n \nBoss\n:\nprintName\n()\n\n  \n--call base class method\n\n  \nBoss\n.\nsuper\n.\nprintName\n(\nself\n)\n\n\n  \nprint\n \n(\n\"I am \"\n..\nself\n.\ntitle\n)\n\n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nboss\n \n=\n \nBoss\n:\nnew\n(\n\"Marky\"\n)\n\n\nboss\n:\nprintName\n()\n\n\n-- Outputs\n\n\n--> My name is Marky\n\n\n--> I am The Main Taco\n\n\n\n\n\n\nSubclassing Subclasses\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\n\n--base class\n\n\nlocal\n \nPerson\n \n=\n \nClassy\n.\ncreate\n(\n\"Person\"\n)\n\n\nfunction\n \nPerson\n:\nconstructor\n(\nname\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n\nend\n\n\n\n--Boss subclass (with defaults)\n\n\nlocal\n \nBoss\n \n=\n \nPerson\n:\nextends\n(\n\"Boss\"\n,\n \n{\n \ntitle\n \n=\n \n\"Top Dog\"\n \n})\n\n\nfunction\n \nBoss\n:\nconstructor\n(\nname\n)\n\n  \nBoss\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n)\n\n\nend\n\n\n\n--Meal subclass\n\n\nlocal\n \nMeal\n \n=\n \nBoss\n:\nextends\n(\n\"Meal\"\n)\n\n\nfunction\n \nMeal\n:\nconstructor\n(\nname\n,\n \nfood\n)\n\n  \nMeal\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n)\n\n\n  \nself\n.\nfood\n \n=\n \nfood\n\n\nend\n\n\n\nfunction\n \nMeal\n:\ngetLunch\n()\n\n  \nlocal\n \nsf\n \n=\n \nstring.format\n\n\n  \nlocal\n \nname\n \n=\n \nself\n.\nname\n\n  \nlocal\n \ntitle\n \n=\n \nself\n.\ntitle\n\n  \nlocal\n \nfood\n \n=\n \nself\n.\nfood\n\n\n  \nreturn\n \nsf\n(\n\"%s the %s is having a %s for lunch.\"\n,\n \nname\n,\n \ntitle\n,\n \nfood\n)\n \n\nend\n\n\n\n--#########################################################\n\n\n--# Instance Examples\n\n\nlocal\n \nmeal1\n \n=\n \nMeal\n:\nnew\n(\n\"Tony\"\n,\n \n\"Sandwhich\"\n)\n\n\nprint\n(\nmeal1\n:\ngetLunch\n())\n\n\n--> Tony the Top Dog is having a Sandwhich for lunch.\n\n\n\nlocal\n \nmeal2\n \n=\n \nMeal\n:\nnew\n(\n\"Tammy\"\n,\n \n\"Salad\"\n)\n\n\nprint\n(\nmeal2\n:\ngetLunch\n())\n\n\n--> Tammy the Top Dog is having a Salad for lunch.",
            "title": "Subclasses"
        },
        {
            "location": "/usage/subclass/#discussion",
            "text": "",
            "title": "Discussion"
        },
        {
            "location": "/usage/subclass/#conventions",
            "text": "Generally a subclass name will be represented as a capitalized string identifier. For example \"Boss\" is a good subclass identifier.",
            "title": "Conventions"
        },
        {
            "location": "/usage/subclass/#subclass-creation",
            "text": "Subclasses are created using the  extends  method on the class you want to extend.",
            "title": "Subclass Creation"
        },
        {
            "location": "/usage/subclass/#super-constructor",
            "text": "When creating a subclass, we are inheriting functionality from another class. The class being subclassed is the \"parent\" or \"superclass\" of the subclass.  When we need access to the \"parent\", we use the  super  property of the subclass. This is used most often when a subclass contains a  constructor  function to pass information up the inheritance chain.  The following example and discussion demonstrates how this works:  local   Classy   =   require ( \"plugin.classy\" )  --Person base class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ) \n   self . name   =   name  end  function   Person : getName () \n   return   self . name  end  --Manager subclass  local   Manager   =   Person : extends ( \"Manager\" )  function   Manager : constructor ( name ) \n   --# Pass up the arguments to the parent class \n   Manager . super . constructor ( self ,   name )  end  --Boss subclass  local   Boss   =   Person : extends ( \"Boss\" )  function   Boss : constructor ( name ) \n   --# Pass up the arguments to the parent class \n   Boss . super . constructor ( self ,   name )  end  --instances  local   manager   =   Manager : new ( \"Jenny\" )  print ( manager : getName ())   --> Jenny  local   boss   =   Boss : new ( \"Jorge\" )  print ( boss : getName ())   --> Jorge   In the example above, we use a  Person  class to represent a person. We have only defined a  name  property and  getName  method, but could add many others. All sublasses of a Person class \"type\" will have a  name  associated with them.  We only want to store the  name  property once. We also have access to the  Person:getName()  method, which again, we only want to define once for any subclass of a Person \"type\".  Our subclasses represent a  Manager  and  Boss , which both fit under the Person \"type\" and so we don't need to recreate the  name  property or  getName  method, which lives in the Person base class.  But, we do need to make sure the Person base class gets the  name  property, so we call the  <Class>.super.constructor  function in each of our subclasses  constructor  functions, which passes the name up.   Because both the Manager and Boss are subclasses of the Person class, their  super  property points to the Person base class. You can use the  super  property to call any methods or manipulate any properties on the \"parent\" class. This is shown in some examples below.    Pay attention to the signature of the  super.constructor  function. You need to make sure you pass a reference of  self  to it, along with any additional arguments, and use only dot ( . ) syntax:  < Class > . super . constructor ( self [,   args ])",
            "title": "Super Constructor"
        },
        {
            "location": "/usage/subclass/#subclass-examples",
            "text": "",
            "title": "Subclass Examples"
        },
        {
            "location": "/usage/subclass/#basic-subclass",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --base class (with defaults)  local   Person   =   Classy . create ( \"Person\" ,   {   age   =   24   })  function   Person : getAge () \n   return   self . age  end  --subclass  local   Boss   =   Person : extends ( \"Boss\" )  --#########################################################  --# Instance Examples  local   boss   =   Boss : new ()  print ( boss : getAge ())   --> 24 (Person default)",
            "title": "Basic SubClass"
        },
        {
            "location": "/usage/subclass/#subclass-with-defaults",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --base class  local   Person   =   Classy . create ( \"Person\" ,   {   name   =   \"Unknown\" ,   age   =   25   })  function   Person : getAge () \n   return   self . age  end  function   Person : getName () \n   return   self . name  end  --subclass  local   Boss   =   Person : extends ( \"Boss\" ,   {   title   =   \"Big Cheese\"   })  function   Boss : getTitle () \n   return   self . title  end  --#########################################################  --# Instance Examples  local   boss   =   Boss : new ()  print ( boss : getTitle ())   --> Big Cheese  print ( boss : getName ())   --> Unknown  print ( boss : getAge ())   --> 25",
            "title": "Subclass with Defaults"
        },
        {
            "location": "/usage/subclass/#subclass-with-constructor",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --base class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ,   age ) \n   self . name   =   name \n   self . age   =   age  end  function   Person : getAge () \n   return   self . age  end  function   Person : getName () \n   return   self . name  end  --subclass  local   Boss   =   Person : extends ( \"Boss\" )  function   Boss : constructor ( name ,   age ,   title ) \n   Boss . super . constructor ( self ,   name ,   age ) \n\n   self . title   =   title  end  function   Boss : getTitle () \n   return   self . title  end  --#########################################################  --# Instance Examples  local   boss   =   Boss : new ( \"Mary\" ,   42 ,   \"Big Cheese\" )  print ( boss : getName ())   --> Mary  print ( boss : getAge ())   --> 42  print ( boss : getTitle ())   --> Big Cheese  local   person   =   Person : new ( \"Jane\" ,   32 )  print ( person : getName ())   --> Jane  print ( person : getTitle ())   -- error (method not on Person class)",
            "title": "SubClass with Constructor"
        },
        {
            "location": "/usage/subclass/#subclass-method-override",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --base class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ) \n   self . name   =   name  end  function   Person : getName () \n   return   self . name  end  --subclass  local   Boss   =   Person : extends ( \"Boss\" )  function   Boss : constructor ( name ) \n   Boss . super . constructor ( self ,   name )  end  --override  function   Boss : getName () \n   return   \"I'm the boss, \" .. self . name  end  --#########################################################  --# Instance Examples  local   person   =   Person : new ( \"Jimmy\" )  local   boss   =   Boss : new ( \"Poppy\" )  print ( person : getName ())   --> Jimmy  print ( boss : getName ())   --> I'm the boss, Poppy",
            "title": "Subclass Method Override"
        },
        {
            "location": "/usage/subclass/#subclass-method-override-with-super-call",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --base class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ) \n   self . name   =   name  end  function   Person : printName () \n   print ( \"My name is \" .. self . name )  end  --sub class (with defaults)  local   Boss   =   Person : extends ( \"Boss\" ,   {   title   =   \"The Main Taco\"   })  function   Boss : constructor ( name ) \n   Boss . super . constructor ( self ,   name )  end  --override  function   Boss : printName () \n   --call base class method \n   Boss . super . printName ( self ) \n\n   print   ( \"I am \" .. self . title )  end  --#########################################################  --# Instance Examples  local   boss   =   Boss : new ( \"Marky\" )  boss : printName ()  -- Outputs  --> My name is Marky  --> I am The Main Taco",
            "title": "Subclass Method Override with Super Call"
        },
        {
            "location": "/usage/subclass/#subclassing-subclasses",
            "text": "local   Classy   =   require ( \"plugin.classy\" )  --base class  local   Person   =   Classy . create ( \"Person\" )  function   Person : constructor ( name ) \n   self . name   =   name  end  --Boss subclass (with defaults)  local   Boss   =   Person : extends ( \"Boss\" ,   {   title   =   \"Top Dog\"   })  function   Boss : constructor ( name ) \n   Boss . super . constructor ( self ,   name )  end  --Meal subclass  local   Meal   =   Boss : extends ( \"Meal\" )  function   Meal : constructor ( name ,   food ) \n   Meal . super . constructor ( self ,   name ) \n\n   self . food   =   food  end  function   Meal : getLunch () \n   local   sf   =   string.format \n\n   local   name   =   self . name \n   local   title   =   self . title \n   local   food   =   self . food \n\n   return   sf ( \"%s the %s is having a %s for lunch.\" ,   name ,   title ,   food )   end  --#########################################################  --# Instance Examples  local   meal1   =   Meal : new ( \"Tony\" ,   \"Sandwhich\" )  print ( meal1 : getLunch ())  --> Tony the Top Dog is having a Sandwhich for lunch.  local   meal2   =   Meal : new ( \"Tammy\" ,   \"Salad\" )  print ( meal2 : getLunch ())  --> Tammy the Top Dog is having a Salad for lunch.",
            "title": "Subclassing Subclasses"
        },
        {
            "location": "/usage/instance/",
            "text": "Instances are self contained objects that contain the methods and properties that were originally set up in the \nclass\n or \nsubclass\n template they are instatiated from.\n\n\nInstances have their own state once created. If the class supports it, you can pass arguments when you create an instance, allowing you to customize the state of each instance.\n\n\nMultiple instances can be created from a single class or subclass. Instances can be passed to other classes and subclasses as well.\n\n\nDiscussion\n\n\nConventions\n\n\nAn instance name is generally represented as a lowercase string. For example, \"person\" is a good instance identifier.\n\n\nInstance Creation\n\n\nInstances are created using the \nnew\n method on the class you want to create an instance of. If a class supports arguments, you can also pass those along with the \nnew\n method.\n\n\nSee the \nClasses\n and \nSubclasses\n sections for details on creating class templates.\n\n\nCalling Methods\n\n\nInstance methods are always called using the Lua colon (\n:\n) syntax, for example:\n\n\n--using colon syntax\n\n\nlocal\n \nname\n \n=\n \nperson\n:\ngetName\n()\n\n\n\n--THIS WILL NOT WORK\n\n\n--using dot syntax\n\n\nlocal\n \nname\n \n=\n \nperson\n.\ngetName\n()\n\n\n\n\n\n\nGet/Set Properties\n\n\nTo get or set any properties of the instance, you use the standard dot (\n.\n) syntax, for example:\n\n\n--get\n\n\nlocal\n \nname\n \n=\n \nperson\n.\nname\n\n\n\n--set\n\n\nperson\n.\nname\n \n=\n \n\"Billy\"\n\n\n\n\n\n\nInstance Example\n\n\nlocal\n \nPerson\n \n=\n \nrequire\n(\n\"classes.Person\"\n)\n\n\n\nlocal\n \np1\n \n=\n \nPerson\n:\nnew\n(\n\"Tammy\"\n)\n\n\nlocal\n \np2\n \n=\n \nPerson\n:\nnew\n(\n\"Jimmy\"\n)\n\n\n\nprint\n(\np1\n:\ngetName\n())\n \n--> Tammy\n\n\nprint\n(\np2\n:\ngetName\n())\n \n--> Jimmy\n\n\n\n\n\n\nSee the class example \nhere\n to get an idea of what the class looks like that produces the instances in the example above.",
            "title": "Instances"
        },
        {
            "location": "/usage/instance/#discussion",
            "text": "",
            "title": "Discussion"
        },
        {
            "location": "/usage/instance/#conventions",
            "text": "An instance name is generally represented as a lowercase string. For example, \"person\" is a good instance identifier.",
            "title": "Conventions"
        },
        {
            "location": "/usage/instance/#instance-creation",
            "text": "Instances are created using the  new  method on the class you want to create an instance of. If a class supports arguments, you can also pass those along with the  new  method.  See the  Classes  and  Subclasses  sections for details on creating class templates.",
            "title": "Instance Creation"
        },
        {
            "location": "/usage/instance/#calling-methods",
            "text": "Instance methods are always called using the Lua colon ( : ) syntax, for example:  --using colon syntax  local   name   =   person : getName ()  --THIS WILL NOT WORK  --using dot syntax  local   name   =   person . getName ()",
            "title": "Calling Methods"
        },
        {
            "location": "/usage/instance/#getset-properties",
            "text": "To get or set any properties of the instance, you use the standard dot ( . ) syntax, for example:  --get  local   name   =   person . name  --set  person . name   =   \"Billy\"",
            "title": "Get/Set Properties"
        },
        {
            "location": "/usage/instance/#instance-example",
            "text": "local   Person   =   require ( \"classes.Person\" )  local   p1   =   Person : new ( \"Tammy\" )  local   p2   =   Person : new ( \"Jimmy\" )  print ( p1 : getName ())   --> Tammy  print ( p2 : getName ())   --> Jimmy   See the class example  here  to get an idea of what the class looks like that produces the instances in the example above.",
            "title": "Instance Example"
        },
        {
            "location": "/tutorial/",
            "text": "In this tutorial we'll use \nClassy OOP\n to create and use some classes in an RPG setting.\n\n\nWhile the focus will be on two main categories; Characters and Weapons, the concepts demonstrated can be applied to a variety of use cases.\n\n\nConcept\n\n\nBuild some classes and subclasses to support the following Character types:\n\n\n\n\nWarrior\n\n\nMage\n\n\nBoss (Warrior)\n\n\n\n\nBuild some classes and subclasses to create the following Weapon types:\n\n\n\n\nSword\n\n\nMagic Wand\n\n\nBattle Axe\n\n\n\n\nCreate a mock battle using these classes and watch it play out (via code).\n\n\nDiscussion\n\n\nWriting OOP classes themselves is fairly simple, the true test of good OOP is how and where you abstract your functionality.\n\n\nIt's real easy to abstract out your functionality too far, so the most important part of the process is thinking through your classes, and their relationships way before your start coding them.\n\n\nWith OOP there are many ways to approach the same problem, so there is always room for debate on best practices. Here we will try and work with a balanced approach of usability and abstraction.\n\n\nClass Trees\n\n\nThe first thing to think about is what our class trees will look like. In our case we know we want a Character and Weapon type, so those will most likely be our base classes.\n\n\nFrom there we will need to create some subclasses to support the differences between the types, like a Warrior and Mage. We will also need to support the differences between a wand and melee weapons.\n\n\nWe also need to think about the characteristics that types will have in common. For instance we can be fairly sure that all Character types will have health (HP), and other attributes like strength, etc.\n\n\nThis is true of Weapon types as well, which will most likely have an attack rating attribute at the very least.\n\n\nAs noted above, our boss character will be a warrior, so our Character class tree might look something like:\n\n\nCharacter\n  Warrior\n    *Boss\n  Mage\n\n\n\n\n\nWhile our Weapon class tree might be:\n\n\nWeapon\n  Melee\n    *Sword\n    *Battle Axe\n  Magic Wand\n\n\n\n\n\nNote: The asterisk (\n*\n) represents a direct instance of the preceding subclass.\n\n\nJust by looking at these class trees, we can get a good idea of how we need to build out our classes and subclasses, which we will start doing in the proceeding sections.\n\n\nProject Layout\n\n\nAs a best practice all classes should live in their own Lua files. Additionally, we will store the class files in a \nclasses\n sub-directory. It's a common practice to capitalize class files.\n\n\nWe could of course have additonal sub-directories in the \nclasses\n directory for \ncharacters\n and \nweapons\n, but we'll skip that for now.\n\n\nProject\n  classes/\n    Character.lua\n    Mage.lua\n    Melee.lua\n    Wand.lua\n    Warrior.lua\n    Weapon.lua\n  main.lua\n\n\n\n\n\nThe \nmain.lua\n file will be our \"battleground\" for the mock battle.",
            "title": "Overview"
        },
        {
            "location": "/tutorial/#concept",
            "text": "Build some classes and subclasses to support the following Character types:   Warrior  Mage  Boss (Warrior)   Build some classes and subclasses to create the following Weapon types:   Sword  Magic Wand  Battle Axe   Create a mock battle using these classes and watch it play out (via code).",
            "title": "Concept"
        },
        {
            "location": "/tutorial/#discussion",
            "text": "Writing OOP classes themselves is fairly simple, the true test of good OOP is how and where you abstract your functionality.  It's real easy to abstract out your functionality too far, so the most important part of the process is thinking through your classes, and their relationships way before your start coding them.  With OOP there are many ways to approach the same problem, so there is always room for debate on best practices. Here we will try and work with a balanced approach of usability and abstraction.",
            "title": "Discussion"
        },
        {
            "location": "/tutorial/#class-trees",
            "text": "The first thing to think about is what our class trees will look like. In our case we know we want a Character and Weapon type, so those will most likely be our base classes.  From there we will need to create some subclasses to support the differences between the types, like a Warrior and Mage. We will also need to support the differences between a wand and melee weapons.  We also need to think about the characteristics that types will have in common. For instance we can be fairly sure that all Character types will have health (HP), and other attributes like strength, etc.  This is true of Weapon types as well, which will most likely have an attack rating attribute at the very least.  As noted above, our boss character will be a warrior, so our Character class tree might look something like:  Character\n  Warrior\n    *Boss\n  Mage  While our Weapon class tree might be:  Weapon\n  Melee\n    *Sword\n    *Battle Axe\n  Magic Wand  Note: The asterisk ( * ) represents a direct instance of the preceding subclass.  Just by looking at these class trees, we can get a good idea of how we need to build out our classes and subclasses, which we will start doing in the proceeding sections.",
            "title": "Class Trees"
        },
        {
            "location": "/tutorial/#project-layout",
            "text": "As a best practice all classes should live in their own Lua files. Additionally, we will store the class files in a  classes  sub-directory. It's a common practice to capitalize class files.  We could of course have additonal sub-directories in the  classes  directory for  characters  and  weapons , but we'll skip that for now.  Project\n  classes/\n    Character.lua\n    Mage.lua\n    Melee.lua\n    Wand.lua\n    Warrior.lua\n    Weapon.lua\n  main.lua  The  main.lua  file will be our \"battleground\" for the mock battle.",
            "title": "Project Layout"
        },
        {
            "location": "/tutorial/character/",
            "text": "Character Classes\n\n\nThe first thing we need to do is determine what our various Character class attributes will be, Then we can then start building out the classes.\n\n\nClass Attributes\n\n\nBase Character\n\n\nProperties\n\n\nTo keep things simple for this tutorial, we will just work with a few properties.\n\n\nCharacter\n  .name\n  .isType\n  .health\n  .maxHealth\n  .weapon\n\n\n\n\n\nMethods\n\n\nNow let's collect the methods we will be needing for the class.\n\n\nCharacter\n  :hit\n  :heal\n  :attack\n  :getName\n  :getType\n  :setHealth\n  :getHealth\n  :getMaxHealth\n  :getWeapon\n  :setWeapon\n  :isDead\n\n\n\n\n\nWarrior\n\n\nThe Warrior will be a subclass of the base Character class, but will not need any additional properties or methods.\n\n\nBoss (Warrior)\n\n\nThe Boss will be a direct instance of the Warrior subclass, which will be demonstrated in the \nMock Battle\n code.\n\n\nMage\n\n\nThe Mage will be a subclass of the Character class, and will need a few additional properties and methods. Since the Mage is a subclass of the Character class, the following properties and methods are \nin addition\n to the properties and methods already on the Character class.\n\n\nProperties\n\n\nMage\n  .mana\n  .maxMana\n\n\n\n\n\nMethods\n\n\nMage\n  :setMana\n  :getMana\n  :getMaxMana\n  :useMana\n  :hasMana\n  :refillMana\n\n\n\n\n\nClasses/Subclasses\n\n\nCharacter\n\n\nThe base Character class.\n\n\nclasses/Character.lua\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\nlocal\n \nCharacter\n \n=\n \nClassy\n.\ncreate\n(\n\"Character\"\n)\n\n\n\nfunction\n \nCharacter\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n  \nself\n.\nisType\n \n=\n \nisType\n\n  \nself\n.\nhealth\n \n=\n \nhealth\n\n  \nself\n.\nmaxHealth\n \n=\n \nmaxHealth\n\n  \nself\n.\nweapon\n \n=\n \nweapon\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\nhit\n(\namount\n)\n\n  \namount\n \n=\n \nself\n:\ngetHealth\n()\n \n-\n \namount\n\n  \nself\n:\nsetHealth\n(\nmath.max\n(\n0\n,\n \namount\n))\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\nheal\n(\namount\n)\n\n  \namount\n \n=\n \nself\n:\ngetHealth\n()\n \n+\n \namount\n\n  \nself\n:\nsetHealth\n(\nmath.min\n(\namount\n,\n \nself\n:\ngetMaxHealth\n()))\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\nattack\n(\ncharacter\n)\n\n  \ncharacter\n:\nhit\n(\nself\n.\nweapon\n:\ngetAttack\n())\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\ngetType\n()\n\n  \nreturn\n \nself\n.\nisType\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\nsetHealth\n(\namount\n)\n\n  \nself\n.\nhealth\n \n=\n \namount\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\ngetHealth\n()\n\n  \nreturn\n \nself\n.\nhealth\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\ngetMaxHealth\n()\n\n  \nreturn\n \nself\n.\nmaxHealth\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\ngetWeapon\n()\n\n  \nreturn\n \nself\n.\nweapon\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\nsetWeapon\n(\nweapon\n)\n\n  \nself\n.\nweapon\n \n=\n \nweapon\n\n\nend\n\n\n\nfunction\n \nCharacter\n:\nisDead\n()\n\n  \nif\n \nself\n:\ngetHealth\n()\n \n<=\n \n0\n \nthen\n\n    \nreturn\n \ntrue\n\n  \nend\n\n  \nreturn\n \nfalse\n\n\nend\n\n\n\nreturn\n \nCharacter\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\nThis is the base class for the subclasses, and is the only time we need to use the \nClassy.create\n method for our character class needs.\n\n\n\n\n\n\nAll sublassess of the Character class will inherit the methods and properties in the class. So this is where we put the most common functionality that can be shared among the subclasses.\n\n\n\n\n\n\n\n\nWarrior\n\n\nThe Warrior subclass. We will also create the Boss instance from this subclass.\n\n\nclasses/Warrior.lua\n\n\nlocal\n \nCharacter\n \n=\n \nrequire\n(\n\"classes.Character\"\n)\n\n\nlocal\n \nWarrior\n \n=\n \nCharacter\n:\nextends\n(\n\"Warrior\"\n)\n\n\n\nfunction\n \nWarrior\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n  \nWarrior\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n\nend\n\n\n\nreturn\n \nWarrior\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\nThe Warrior is a subclass of the Character class. We need to pull in the Character class by using \nrequire\n so that we can \"extend\" it.\n\n\n\n\n\n\nTo create the Warrior class we use the \nextends\n method on the Character class, not \nClassy.create\n.\n\n\n\n\n\n\nWe need to pass in the same arguments that the base Character class is expecting in the \nconstructor\n function. We use the \nsuper\n property to pass those values up the hierarchy. \n\n\n\n\n\n\nThe Warrior subclass uses all of the original methods and properties of the base Character class. We could just create a direct instance from the Character class, but by creating a subclass of the Warior type we can add specialized functionality in the future to the Warrior class very easily.\n\n\n\n\n\n\n\n\nMage\n\n\nThe Mage subclass.\n\n\nclasses/Mage.lua\n\n\nlocal\n \nCharacter\n \n=\n \nrequire\n(\n\"classes.Character\"\n)\n\n\nlocal\n \nMage\n \n=\n \nCharacter\n:\nextends\n(\n\"Mage\"\n)\n\n\n\nfunction\n \nMage\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n,\n \nmana\n,\n \nmaxMana\n)\n\n  \nMage\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n\n  \nself\n.\nmana\n \n=\n \nmana\n\n  \nself\n.\nmaxMana\n \n=\n \nmaxMana\n\n\nend\n\n\n\n--override parent method\n\n\nfunction\n \nMage\n:\nattack\n(\ncharacter\n)\n\n  \nif\n \nself\n:\ngetWeapon\n():\nhasCharges\n()\n \nthen\n\n    \nself\n:\ngetWeapon\n():\nuseCharges\n(\n3\n)\n\n    \nself\n:\nsetMana\n(\nmath.max\n(\n0\n,\n \nself\n:\ngetMana\n()\n \n-\n \n10\n))\n\n    \n--Call parent attack method\n\n    \nMage\n.\nsuper\n.\nattack\n(\nself\n,\n \ncharacter\n)\n\n  \nend\n\n\nend\n\n\n\nfunction\n \nMage\n:\nsetMana\n(\namount\n)\n\n  \nself\n.\nmana\n \n=\n \namount\n\n\nend\n\n\n\nfunction\n \nMage\n:\ngetMana\n()\n\n  \nreturn\n \nself\n.\nmana\n\n\nend\n\n\n\nfunction\n \nMage\n:\ngetMaxMana\n()\n\n  \nreturn\n \nself\n.\nmaxMana\n\n\nend\n\n\n\nfunction\n \nMage\n:\nuseMana\n(\namount\n)\n\n  \namount\n \n=\n \nself\n:\ngetMana\n()\n \n-\n \namount\n\n  \nself\n:\nsetMana\n(\nmath.max\n(\n0\n,\n \namount\n))\n\n\nend\n\n\n\nfunction\n \nMage\n:\nhasMana\n()\n\n  \nif\n \nself\n:\ngetMana\n()\n \n>\n \n0\n \nthen\n\n    \nreturn\n \ntrue\n\n  \nend\n\n  \nreturn\n \nfalse\n\n\nend\n\n\n\nfunction\n \nMage\n:\nrefillMana\n(\namount\n)\n\n  \namount\n \n=\n \namount\n \nor\n \nself\n:\ngetMaxMana\n()\n\n  \namount\n \n=\n \nself\n:\ngetMana\n()\n \n+\n \namount\n\n  \nself\n:\nsetMana\n(\nmath.min\n(\namount\n,\n \nself\n:\ngetMaxMana\n()))\n\n\nend\n\n\n\nreturn\n \nMage\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\nThe Mage is a subclass of the Character class. We need to pull in the Character class by using \nrequire\n so that we can \"extend\" it.\n\n\n\n\n\n\nTo create the Mage class we use the \nextends\n method on the Character class, not \nClassy.create\n.\n\n\n\n\n\n\nThe Mage class has a number of customized methods and properties added to it. These will be available \nin addition\n to what is in the base Character class.\n\n\n\n\n\n\nThe Mage subclass takes some additional arguments to its \nconstructor\n function, that are specific to the subclass(\nmana\n and \nmaxMana\n). We still need to pass the arguments that the base Character class is expecting in the \nconstructor\n function. We use the \nsuper\n property to pass those values up the hierarchy, but only including the ones needed by the base Character class.",
            "title": "Characters"
        },
        {
            "location": "/tutorial/character/#character-classes",
            "text": "The first thing we need to do is determine what our various Character class attributes will be, Then we can then start building out the classes.",
            "title": "Character Classes"
        },
        {
            "location": "/tutorial/character/#class-attributes",
            "text": "",
            "title": "Class Attributes"
        },
        {
            "location": "/tutorial/character/#base-character",
            "text": "",
            "title": "Base Character"
        },
        {
            "location": "/tutorial/character/#properties",
            "text": "To keep things simple for this tutorial, we will just work with a few properties.  Character\n  .name\n  .isType\n  .health\n  .maxHealth\n  .weapon",
            "title": "Properties"
        },
        {
            "location": "/tutorial/character/#methods",
            "text": "Now let's collect the methods we will be needing for the class.  Character\n  :hit\n  :heal\n  :attack\n  :getName\n  :getType\n  :setHealth\n  :getHealth\n  :getMaxHealth\n  :getWeapon\n  :setWeapon\n  :isDead",
            "title": "Methods"
        },
        {
            "location": "/tutorial/character/#warrior",
            "text": "The Warrior will be a subclass of the base Character class, but will not need any additional properties or methods.",
            "title": "Warrior"
        },
        {
            "location": "/tutorial/character/#boss-warrior",
            "text": "The Boss will be a direct instance of the Warrior subclass, which will be demonstrated in the  Mock Battle  code.",
            "title": "Boss (Warrior)"
        },
        {
            "location": "/tutorial/character/#mage",
            "text": "The Mage will be a subclass of the Character class, and will need a few additional properties and methods. Since the Mage is a subclass of the Character class, the following properties and methods are  in addition  to the properties and methods already on the Character class.",
            "title": "Mage"
        },
        {
            "location": "/tutorial/character/#properties_1",
            "text": "Mage\n  .mana\n  .maxMana",
            "title": "Properties"
        },
        {
            "location": "/tutorial/character/#methods_1",
            "text": "Mage\n  :setMana\n  :getMana\n  :getMaxMana\n  :useMana\n  :hasMana\n  :refillMana",
            "title": "Methods"
        },
        {
            "location": "/tutorial/character/#classessubclasses",
            "text": "",
            "title": "Classes/Subclasses"
        },
        {
            "location": "/tutorial/character/#character",
            "text": "The base Character class.  classes/Character.lua  local   Classy   =   require ( \"plugin.classy\" )  local   Character   =   Classy . create ( \"Character\" )  function   Character : constructor ( name ,   isType ,   health ,   maxHealth ,   weapon ) \n   self . name   =   name \n   self . isType   =   isType \n   self . health   =   health \n   self . maxHealth   =   maxHealth \n   self . weapon   =   weapon  end  function   Character : hit ( amount ) \n   amount   =   self : getHealth ()   -   amount \n   self : setHealth ( math.max ( 0 ,   amount ))  end  function   Character : heal ( amount ) \n   amount   =   self : getHealth ()   +   amount \n   self : setHealth ( math.min ( amount ,   self : getMaxHealth ()))  end  function   Character : attack ( character ) \n   character : hit ( self . weapon : getAttack ())  end  function   Character : getName () \n   return   self . name  end  function   Character : getType () \n   return   self . isType  end  function   Character : setHealth ( amount ) \n   self . health   =   amount  end  function   Character : getHealth () \n   return   self . health  end  function   Character : getMaxHealth () \n   return   self . maxHealth  end  function   Character : getWeapon () \n   return   self . weapon  end  function   Character : setWeapon ( weapon ) \n   self . weapon   =   weapon  end  function   Character : isDead () \n   if   self : getHealth ()   <=   0   then \n     return   true \n   end \n   return   false  end  return   Character",
            "title": "Character"
        },
        {
            "location": "/tutorial/character/#notes",
            "text": "This is the base class for the subclasses, and is the only time we need to use the  Classy.create  method for our character class needs.    All sublassess of the Character class will inherit the methods and properties in the class. So this is where we put the most common functionality that can be shared among the subclasses.",
            "title": "Notes"
        },
        {
            "location": "/tutorial/character/#warrior_1",
            "text": "The Warrior subclass. We will also create the Boss instance from this subclass.  classes/Warrior.lua  local   Character   =   require ( \"classes.Character\" )  local   Warrior   =   Character : extends ( \"Warrior\" )  function   Warrior : constructor ( name ,   isType ,   health ,   maxHealth ,   weapon ) \n   Warrior . super . constructor ( self ,   name ,   isType ,   health ,   maxHealth ,   weapon )  end  return   Warrior",
            "title": "Warrior"
        },
        {
            "location": "/tutorial/character/#notes_1",
            "text": "The Warrior is a subclass of the Character class. We need to pull in the Character class by using  require  so that we can \"extend\" it.    To create the Warrior class we use the  extends  method on the Character class, not  Classy.create .    We need to pass in the same arguments that the base Character class is expecting in the  constructor  function. We use the  super  property to pass those values up the hierarchy.     The Warrior subclass uses all of the original methods and properties of the base Character class. We could just create a direct instance from the Character class, but by creating a subclass of the Warior type we can add specialized functionality in the future to the Warrior class very easily.",
            "title": "Notes"
        },
        {
            "location": "/tutorial/character/#mage_1",
            "text": "The Mage subclass.  classes/Mage.lua  local   Character   =   require ( \"classes.Character\" )  local   Mage   =   Character : extends ( \"Mage\" )  function   Mage : constructor ( name ,   isType ,   health ,   maxHealth ,   weapon ,   mana ,   maxMana ) \n   Mage . super . constructor ( self ,   name ,   isType ,   health ,   maxHealth ,   weapon ) \n\n   self . mana   =   mana \n   self . maxMana   =   maxMana  end  --override parent method  function   Mage : attack ( character ) \n   if   self : getWeapon (): hasCharges ()   then \n     self : getWeapon (): useCharges ( 3 ) \n     self : setMana ( math.max ( 0 ,   self : getMana ()   -   10 )) \n     --Call parent attack method \n     Mage . super . attack ( self ,   character ) \n   end  end  function   Mage : setMana ( amount ) \n   self . mana   =   amount  end  function   Mage : getMana () \n   return   self . mana  end  function   Mage : getMaxMana () \n   return   self . maxMana  end  function   Mage : useMana ( amount ) \n   amount   =   self : getMana ()   -   amount \n   self : setMana ( math.max ( 0 ,   amount ))  end  function   Mage : hasMana () \n   if   self : getMana ()   >   0   then \n     return   true \n   end \n   return   false  end  function   Mage : refillMana ( amount ) \n   amount   =   amount   or   self : getMaxMana () \n   amount   =   self : getMana ()   +   amount \n   self : setMana ( math.min ( amount ,   self : getMaxMana ()))  end  return   Mage",
            "title": "Mage"
        },
        {
            "location": "/tutorial/character/#notes_2",
            "text": "The Mage is a subclass of the Character class. We need to pull in the Character class by using  require  so that we can \"extend\" it.    To create the Mage class we use the  extends  method on the Character class, not  Classy.create .    The Mage class has a number of customized methods and properties added to it. These will be available  in addition  to what is in the base Character class.    The Mage subclass takes some additional arguments to its  constructor  function, that are specific to the subclass( mana  and  maxMana ). We still need to pass the arguments that the base Character class is expecting in the  constructor  function. We use the  super  property to pass those values up the hierarchy, but only including the ones needed by the base Character class.",
            "title": "Notes"
        },
        {
            "location": "/tutorial/weapon/",
            "text": "Weapon Classes\n\n\nNow we need to determine what our various Weapon class attributes will be, Then we can then start building out the classes.\n\n\nClass Attributes\n\n\nBase Weapon\n\n\nProperties\n\n\nWeapon\n  .name\n  .isType\n  .attack\n\n\n\n\n\nMethods\n\n\nWeapon\n  :getName\n  :getType\n  :getAttack\n\n\n\n\n\nMelee Weapon\n\n\nThe Melee Weapon will be a subclass of the Weapon type, but will require no additional properties of methods.\n\n\nThe sword and battle axe will be direct instances of the Melee subclass. \n\n\nMagic Wand\n\n\nThe magic wand will be a subclass of the base Weapon class, and will have a few additional properties and methods.\n\n\nProperties\n\n\nMagic Wand\n  .manaCost\n\n\n\n\n\nMethods\n\n\nMagic Wand\n  :getManaCost\n\n\n\n\n\nClasses/Subclasses\n\n\nWeapon\n\n\nThe base Weapon class.\n\n\nclasses/Weapon.lua\n\n\nlocal\n \nClassy\n \n=\n \nrequire\n(\n\"plugin.classy\"\n)\n\n\nlocal\n \nWeapon\n \n=\n \nClassy\n.\ncreate\n(\n\"Weapon\"\n)\n\n\n\nfunction\n \nWeapon\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nattack\n)\n\n  \nself\n.\nname\n \n=\n \nname\n\n  \nself\n.\nisType\n \n=\n \nisType\n\n  \nself\n.\nattack\n \n=\n \nattack\n\n\nend\n\n\n\nfunction\n \nWeapon\n:\ngetName\n()\n\n  \nreturn\n \nself\n.\nname\n\n\nend\n\n\n\nfunction\n \nWeapon\n:\ngetType\n()\n\n  \nreturn\n \nself\n.\nisType\n\n\nend\n\n\n\nfunction\n \nWeapon\n:\ngetAttack\n()\n\n  \nreturn\n \nself\n.\nattack\n\n\nend\n\n\n\nreturn\n \nWeapon\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\nThis is the base class for the subclasses, and is the only time we need to use the \nClassy.create\n method for our weapon class needs.\n\n\n\n\n\n\nAll sublassess of the Weapon class will inherit the methods and properties in the class. So this is where we put the most common functionality that can be shared among the subclasses.\n\n\n\n\n\n\n\n\nMelee\n\n\nThe Melee subclass.\n\n\nclasses/Melee.lua\n\n\nlocal\n \nWeapon\n \n=\n \nrequire\n(\n\"classes.Weapon\"\n)\n\n\nlocal\n \nMelee\n \n=\n \nWeapon\n:\nextends\n(\n\"Melee\"\n)\n\n\n\nfunction\n \nMelee\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nattack\n)\n\n  \nMelee\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nattack\n)\n\n\nend\n\n\n\nreturn\n \nMelee\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\nThe Melee type is a subclass of the Weapon class. We need to pull in the Weapon class by using \nrequire\n so that we can \"extend\" it.\n\n\n\n\n\n\nTo create the Melee class we use the \nextends\n method on the Weapon class, not \nClassy.create\n.\n\n\n\n\n\n\nWe need to pass in the same arguments that the base Weapon class is expecting in the \nconstructor\n function. We use the \nsuper\n property to pass those values up the hierarchy. \n\n\n\n\n\n\nThe Melee subclass uses all of the original methods and properties of the base Weapon class. We could just create a direct instance from the Weapon class, but by creating a subclass of the Melee type we can add specialized functionality in the future to the Melee class very easily.\n\n\n\n\n\n\n\n\nWand\n\n\nThe Wand subclass.\n\n\nclasses/Wand.lua\n\n\nlocal\n \nWeapon\n \n=\n \nrequire\n(\n\"classes.Weapon\"\n)\n\n\nlocal\n \nWand\n \n=\n \nWeapon\n:\nextends\n(\n\"Wand\"\n)\n\n\n\nfunction\n \nWand\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nattack\n,\n \nmanaCost\n)\n\n  \nWand\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nattack\n)\n\n\n  \nself\n.\nmanaCost\n \n=\n \nmanaCost\n\n\nend\n\n\n\nfunction\n \nWand\n:\ngetManaCost\n()\n\n  \nreturn\n \nself\n.\nmanaCost\n\n\nend\n\n\n\nreturn\n \nWand\n\n\n\n\n\n\nNotes\n\n\n\n\n\n\nThe Wand is a subclass of the Weapon class. We need to pull in the Weapon class by using \nrequire\n so that we can \"extend\" it.\n\n\n\n\n\n\nTo create the Wand class we use the \nextends\n method on the Weapon class, not \nClassy.create\n.\n\n\n\n\n\n\nThe Wand class has an extra properties and method added to it. This will be available \nin addition\n to what is in the base Weapon class.\n\n\n\n\n\n\nThe Wand subclass takes an additional argument to its \nconstructor\n function that is specific to the subclass(\nmanaCost\n). We still need to pass the arguments that the base Weapon class is expecting in the \nconstructor\n function. We use the \nsuper\n property to pass those values up the hierarchy, but only including the ones needed by the base Weapon class.",
            "title": "Weapons"
        },
        {
            "location": "/tutorial/weapon/#weapon-classes",
            "text": "Now we need to determine what our various Weapon class attributes will be, Then we can then start building out the classes.",
            "title": "Weapon Classes"
        },
        {
            "location": "/tutorial/weapon/#class-attributes",
            "text": "",
            "title": "Class Attributes"
        },
        {
            "location": "/tutorial/weapon/#base-weapon",
            "text": "",
            "title": "Base Weapon"
        },
        {
            "location": "/tutorial/weapon/#properties",
            "text": "Weapon\n  .name\n  .isType\n  .attack",
            "title": "Properties"
        },
        {
            "location": "/tutorial/weapon/#methods",
            "text": "Weapon\n  :getName\n  :getType\n  :getAttack",
            "title": "Methods"
        },
        {
            "location": "/tutorial/weapon/#melee-weapon",
            "text": "The Melee Weapon will be a subclass of the Weapon type, but will require no additional properties of methods.  The sword and battle axe will be direct instances of the Melee subclass.",
            "title": "Melee Weapon"
        },
        {
            "location": "/tutorial/weapon/#magic-wand",
            "text": "The magic wand will be a subclass of the base Weapon class, and will have a few additional properties and methods.",
            "title": "Magic Wand"
        },
        {
            "location": "/tutorial/weapon/#properties_1",
            "text": "Magic Wand\n  .manaCost",
            "title": "Properties"
        },
        {
            "location": "/tutorial/weapon/#methods_1",
            "text": "Magic Wand\n  :getManaCost",
            "title": "Methods"
        },
        {
            "location": "/tutorial/weapon/#classessubclasses",
            "text": "",
            "title": "Classes/Subclasses"
        },
        {
            "location": "/tutorial/weapon/#weapon",
            "text": "The base Weapon class.  classes/Weapon.lua  local   Classy   =   require ( \"plugin.classy\" )  local   Weapon   =   Classy . create ( \"Weapon\" )  function   Weapon : constructor ( name ,   isType ,   attack ) \n   self . name   =   name \n   self . isType   =   isType \n   self . attack   =   attack  end  function   Weapon : getName () \n   return   self . name  end  function   Weapon : getType () \n   return   self . isType  end  function   Weapon : getAttack () \n   return   self . attack  end  return   Weapon",
            "title": "Weapon"
        },
        {
            "location": "/tutorial/weapon/#notes",
            "text": "This is the base class for the subclasses, and is the only time we need to use the  Classy.create  method for our weapon class needs.    All sublassess of the Weapon class will inherit the methods and properties in the class. So this is where we put the most common functionality that can be shared among the subclasses.",
            "title": "Notes"
        },
        {
            "location": "/tutorial/weapon/#melee",
            "text": "The Melee subclass.  classes/Melee.lua  local   Weapon   =   require ( \"classes.Weapon\" )  local   Melee   =   Weapon : extends ( \"Melee\" )  function   Melee : constructor ( name ,   isType ,   attack ) \n   Melee . super . constructor ( self ,   name ,   isType ,   attack )  end  return   Melee",
            "title": "Melee"
        },
        {
            "location": "/tutorial/weapon/#notes_1",
            "text": "The Melee type is a subclass of the Weapon class. We need to pull in the Weapon class by using  require  so that we can \"extend\" it.    To create the Melee class we use the  extends  method on the Weapon class, not  Classy.create .    We need to pass in the same arguments that the base Weapon class is expecting in the  constructor  function. We use the  super  property to pass those values up the hierarchy.     The Melee subclass uses all of the original methods and properties of the base Weapon class. We could just create a direct instance from the Weapon class, but by creating a subclass of the Melee type we can add specialized functionality in the future to the Melee class very easily.",
            "title": "Notes"
        },
        {
            "location": "/tutorial/weapon/#wand",
            "text": "The Wand subclass.  classes/Wand.lua  local   Weapon   =   require ( \"classes.Weapon\" )  local   Wand   =   Weapon : extends ( \"Wand\" )  function   Wand : constructor ( name ,   isType ,   attack ,   manaCost ) \n   Wand . super . constructor ( self ,   name ,   isType ,   attack ) \n\n   self . manaCost   =   manaCost  end  function   Wand : getManaCost () \n   return   self . manaCost  end  return   Wand",
            "title": "Wand"
        },
        {
            "location": "/tutorial/weapon/#notes_2",
            "text": "The Wand is a subclass of the Weapon class. We need to pull in the Weapon class by using  require  so that we can \"extend\" it.    To create the Wand class we use the  extends  method on the Weapon class, not  Classy.create .    The Wand class has an extra properties and method added to it. This will be available  in addition  to what is in the base Weapon class.    The Wand subclass takes an additional argument to its  constructor  function that is specific to the subclass( manaCost ). We still need to pass the arguments that the base Weapon class is expecting in the  constructor  function. We use the  super  property to pass those values up the hierarchy, but only including the ones needed by the base Weapon class.",
            "title": "Notes"
        },
        {
            "location": "/tutorial/discussion/",
            "text": "Now that all the classes have been created, let's look at a few important key points in the classes and subclasses.\n\n\nGetters/Setters\n\n\nYou should notice that for every property there is at least a \nget<Prop>\n method and some properties also have a \nset<Prop>\n method.\n\n\nThis is a good practice as it allows one to add additional needs in the future when manipulating a property. You should never directly set a property, but always use its \"getter\" or \"setter\" for better control.\n\n\nFor example, in our Mage class:\n\n\n...\n\n\n\nfunction\n \nMage\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n,\n \nmana\n,\n \nmaxMana\n)\n\n  \nMage\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n\n  \nself\n.\nmana\n \n=\n \nmana\n\n  \nself\n.\nmaxMana\n \n=\n \nmaxMana\n\n\nend\n\n\n\nfunction\n \nMage\n:\nsetMana\n(\namount\n)\n\n  \nself\n.\nmana\n \n=\n \namount\n\n\nend\n\n\n\nfunction\n \nMage\n:\ngetMana\n()\n\n  \nreturn\n \nself\n.\nmana\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nWe have a \nmana\n property, but we would always use the \ngetMana\n and \nsetMana\n methods to manipulate that property. You would never want to to do \nself.mana = val\n or \nmana = self.mana\n in any of your methods.\n\n\nTo refill our mana we use a seperate method called \nrefillMana\n:\n\n\n...\n\n\n\nfunction\n \nMage\n:\nrefillMana\n(\namount\n)\n\n  \namount\n \n=\n \namount\n \nor\n \nself\n:\ngetMaxMana\n()\n\n  \namount\n \n=\n \nself\n:\ngetMana\n()\n \n+\n \namount\n\n  \nself\n:\nsetMana\n(\nmath.min\n(\namount\n,\n \nself\n:\ngetMaxMana\n()))\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nYou should notice that we never call the property directly, but use the \"getter\" and \"setter\" methods instead. \n\n\nIn the example code above we \"clamp\" the \nmana\n value to the \nmaxMana\n (using \nmath.min\n). It's better to do this in a seperate method so we don't pollute the setting of the raw \nmana\n property.\n\n\nThe \nsetMana\n method itself will take any value:\n\n\n...\n\n\n\nfunction\n \nMage\n:\nsetMana\n(\namount\n)\n\n  \nself\n.\nmana\n \n=\n \namount\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nThis allows us to override the \nmaxMana\n if we want to with a \"buff\" or potion. For example, let's assume we have some \"buff\" functionality built into our Mage class that adds additional bonus mana when active, we can then easily adjust our \nrefillMana\n method:\n\n\n...\n\n\n\nfunction\n \nMage\n:\nrefillMana\n(\namount\n)\n\n  \namount\n \n=\n \namount\n \nor\n \nself\n:\ngetMaxMana\n()\n\n  \namount\n \n=\n \nself\n:\ngetMana\n()\n \n+\n \namount\n\n\n  \n--do we have a buff?\n\n  \nif\n \nself\n:\nhasActiveBuff\n()\n \nthen\n\n    \namount\n \n=\n \namount\n \n+\n \nself\n:\ngetBuffValue\n()\n\n    \nself\n:\nsetMana\n(\namount\n)\n \n--no clamping here\n\n  \nelse\n\n    \nself\n:\nsetMana\n(\nmath.min\n(\namount\n,\n \nself\n:\ngetMaxMana\n()))\n\n  \nend\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nYou could put the \nrefillMana\n functionality directly in the \nsetMana\n method, but it is better to abstract the functionality out, keeping the property \"getter\" and \"setter\" clean.\n\n\nSubclass Notes\n\n\nAll subclass are created using the \nextends\n method on the class or subclass we want to extend. We do not use \nClassy.create\n, but we need to pull in the base class using \nrequire\n so that we can subclass it.\n\n\n...\n\n\n\n--The base class (or subclass)\n\n\nlocal\n \nCharacter\n \n=\n \nrequire\n(\n\"classes.Character\"\n)\n\n\n\n--Create a subclass by \"extending\"\n\n\nlocal\n \nWarrior\n \n=\n \nCharacter\n:\nextends\n(\n\"Warrior\"\n)\n\n\n\n...\n\n\n\n\n\n\nWhen creating a subclass, we need to make sure to pass up the required base class arguments by using the \nconstructor\n function. This done using the \nsuper\n property:\n\n\n...\n\n\n\nfunction\n \nWarrior\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n\n  \n--Pass the arguments up the hierarchy using \"super\"\n\n  \nWarrior\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n\nend\n\n\n\n...\n\n\n\n\n\n\n \nPay attention to the signature of the \nsuper.constructor\n function. You need to make sure you pass a reference of \nself\n to it, along with any additional arguments, and use only dot (\n.\n) syntax:\n\n\n<\nClass\n>\n.\nsuper\n.\nconstructor\n(\nself\n[,\n \nargs\n])\n\n\n\n\n\n\nThis is very important to remember, or your subclasses will not work as expected.\n.\n\n\nIn the case of subclasses that have their own specific properties, we only need to pass the ones the base class needs, and we then store the others on the subclass itself:\n\n\n...\n\n\n\nfunction\n \nMage\n:\nconstructor\n(\nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n,\n \nmana\n,\n \nmaxMana\n)\n\n\n  \n--Pass the base class arguments up the hierarchy using \"super\"\n\n  \nMage\n.\nsuper\n.\nconstructor\n(\nself\n,\n \nname\n,\n \nisType\n,\n \nhealth\n,\n \nmaxHealth\n,\n \nweapon\n)\n\n\n  \n--Store properties specific to this subclass\n\n  \nself\n.\nmana\n \n=\n \nmana\n\n  \nself\n.\nmaxMana\n \n=\n \nmaxMana\n\n\nend\n\n\n\n...",
            "title": "Discussion"
        },
        {
            "location": "/tutorial/discussion/#getterssetters",
            "text": "You should notice that for every property there is at least a  get<Prop>  method and some properties also have a  set<Prop>  method.  This is a good practice as it allows one to add additional needs in the future when manipulating a property. You should never directly set a property, but always use its \"getter\" or \"setter\" for better control.  For example, in our Mage class:  ...  function   Mage : constructor ( name ,   isType ,   health ,   maxHealth ,   weapon ,   mana ,   maxMana ) \n   Mage . super . constructor ( self ,   name ,   isType ,   health ,   maxHealth ,   weapon ) \n\n   self . mana   =   mana \n   self . maxMana   =   maxMana  end  function   Mage : setMana ( amount ) \n   self . mana   =   amount  end  function   Mage : getMana () \n   return   self . mana  end  ...   We have a  mana  property, but we would always use the  getMana  and  setMana  methods to manipulate that property. You would never want to to do  self.mana = val  or  mana = self.mana  in any of your methods.  To refill our mana we use a seperate method called  refillMana :  ...  function   Mage : refillMana ( amount ) \n   amount   =   amount   or   self : getMaxMana () \n   amount   =   self : getMana ()   +   amount \n   self : setMana ( math.min ( amount ,   self : getMaxMana ()))  end  ...   You should notice that we never call the property directly, but use the \"getter\" and \"setter\" methods instead.   In the example code above we \"clamp\" the  mana  value to the  maxMana  (using  math.min ). It's better to do this in a seperate method so we don't pollute the setting of the raw  mana  property.  The  setMana  method itself will take any value:  ...  function   Mage : setMana ( amount ) \n   self . mana   =   amount  end  ...   This allows us to override the  maxMana  if we want to with a \"buff\" or potion. For example, let's assume we have some \"buff\" functionality built into our Mage class that adds additional bonus mana when active, we can then easily adjust our  refillMana  method:  ...  function   Mage : refillMana ( amount ) \n   amount   =   amount   or   self : getMaxMana () \n   amount   =   self : getMana ()   +   amount \n\n   --do we have a buff? \n   if   self : hasActiveBuff ()   then \n     amount   =   amount   +   self : getBuffValue () \n     self : setMana ( amount )   --no clamping here \n   else \n     self : setMana ( math.min ( amount ,   self : getMaxMana ())) \n   end  end  ...   You could put the  refillMana  functionality directly in the  setMana  method, but it is better to abstract the functionality out, keeping the property \"getter\" and \"setter\" clean.",
            "title": "Getters/Setters"
        },
        {
            "location": "/tutorial/discussion/#subclass-notes",
            "text": "All subclass are created using the  extends  method on the class or subclass we want to extend. We do not use  Classy.create , but we need to pull in the base class using  require  so that we can subclass it.  ...  --The base class (or subclass)  local   Character   =   require ( \"classes.Character\" )  --Create a subclass by \"extending\"  local   Warrior   =   Character : extends ( \"Warrior\" )  ...   When creating a subclass, we need to make sure to pass up the required base class arguments by using the  constructor  function. This done using the  super  property:  ...  function   Warrior : constructor ( name ,   isType ,   health ,   maxHealth ,   weapon ) \n\n   --Pass the arguments up the hierarchy using \"super\" \n   Warrior . super . constructor ( self ,   name ,   isType ,   health ,   maxHealth ,   weapon )  end  ...     Pay attention to the signature of the  super.constructor  function. You need to make sure you pass a reference of  self  to it, along with any additional arguments, and use only dot ( . ) syntax:  < Class > . super . constructor ( self [,   args ])   This is very important to remember, or your subclasses will not work as expected. .  In the case of subclasses that have their own specific properties, we only need to pass the ones the base class needs, and we then store the others on the subclass itself:  ...  function   Mage : constructor ( name ,   isType ,   health ,   maxHealth ,   weapon ,   mana ,   maxMana ) \n\n   --Pass the base class arguments up the hierarchy using \"super\" \n   Mage . super . constructor ( self ,   name ,   isType ,   health ,   maxHealth ,   weapon ) \n\n   --Store properties specific to this subclass \n   self . mana   =   mana \n   self . maxMana   =   maxMana  end  ...",
            "title": "Subclass Notes"
        },
        {
            "location": "/tutorial/battle/",
            "text": "So now that we have all of our classes and subclasses set up we should take a look at using them. We'll do this through code, and observe the output in the Corona console.\n\n\nIf you want to follow along, you can \ndownload the demo project\n which contains the \"battle\" code as well as all the classes in a Corona project.\n\n\nHere I'm just going to point out some important parts of the code. You can view the full code further below.\n\n\nCode Setup\n\n\nAt the start of the file we localize a few \nstring\n methods for output. You might notice we don't need to \nrequire\n the \nClassy OOP\n plugin here. As a matter of fact we've only needed the plugin in a couple of the code class pages.\n\n\nClasses\n\n\nCharacters\n\n\nNow we bring in the \nCharacter\n classes that we created:\n\n\n...\n\n\n\nlocal\n \nMage\n    \n=\n \nrequire\n(\n\"classes.Mage\"\n)\n\n\nlocal\n \nWarrior\n \n=\n \nrequire\n(\n\"classes.Warrior\"\n)\n\n\n\n...\n\n\n\n\n\n\nYou should notice that we don't need to bring in the base \nCharacter\n class file. We only need the subclasses, as they already have references to the base \nCharacter\n class.\n\n\nWeapons\n\n\nWe follow up with the \nWeapon\n classes:\n\n\n...\n\n\n\nlocal\n \nWand\n    \n=\n \nrequire\n(\n\"classes.Wand\"\n)\n\n\nlocal\n \nMelee\n   \n=\n \nrequire\n(\n\"classes.Melee\"\n)\n\n\n\n...\n\n\n\n\n\n\nAgain, we don't need the base \nWeapon\n class file. We only need the subclasses.\n\n\nInstances\n\n\nWeapons\n\n\nNow let's create our weapon instances. We are doing this first so that we can \"equip\" them on our upcoming character instances. We could of course equip them after the fact using the character class \nsetWeapon\n method, but this is just as well.\n\n\n...\n\n\n\nlocal\n \nsword\n \n=\n \nMelee\n:\nnew\n(\n'Titan Blade'\n,\n \n'sword'\n,\n \n30\n)\n\n\nlocal\n \naxe\n   \n=\n \nMelee\n:\nnew\n(\n'Gilded Axe'\n,\n \n'battle axe'\n,\n \n50\n)\n\n\nlocal\n \nwand\n  \n=\n \nWand\n:\nnew\n(\n'Enchanted Stick'\n,\n \n'wand'\n,\n \n10\n)\n\n\n\n...\n\n\n\n\n\n\nAbove we are creating two \nMelee\n class weapons, and one \nWand\n. The \nWeapon\n base class takes a \nname\n, \nisType\n, and \nattack\n argument, which we pass for each of the instaces we created.\n\n\nWe now have three weapon instances that we can \"equip\" on our characters.\n\n\nCharacters\n\n\nBuilding the character instances is very much the same as our weapons:\n\n\n...\n\n\n\nlocal\n \nhero\n  \n=\n \nWarrior\n:\nnew\n(\n'Thundar'\n,\n \n'warrior'\n,\n \n100\n,\n \n100\n,\n \nsword\n)\n\n\nlocal\n \nboss\n  \n=\n \nWarrior\n:\nnew\n(\n'Azarak'\n,\n \n'warrior'\n,\n \n200\n,\n \n200\n,\n \naxe\n)\n\n\nlocal\n \nmage\n  \n=\n \nMage\n:\nnew\n(\n'Chalice'\n,\n \n'mage'\n,\n \n60\n,\n \n60\n,\n \nwand\n,\n \n100\n,\n \n100\n)\n\n\n\n...\n\n\n\n\n\n\nAbove we have created two warriors, one a hero and the other a boss (baddie). We also have a mage along with us.\n\n\nThe \nWarrior\n class needs a \nname\n, \nisType\n, \nhealth\n, \nmaxHealth\n, and \nweapon\n argument passed to it. The \nMage\n is a special subclass that also takes a \nmana\n and \nmaxMana\n argument along with the others.\n\n\nAs you can see, we pass the previously generated weapon instances directly to the character instances.\n\n\nOutput Methods\n\n\nAfter our charactes and weapons there are a handful of utility methods to help print out the \"battle\" status as it takes place. These should be fairly self-explanatory.\n\n\nThere is one method that should be pointed out:\n\n\n...\n\n\n\nlocal\n \nfunction\n \nattackStatus\n(\nattacker\n,\n \nattacked\n)\n\n  \nlocal\n \nweapon\n \n=\n \nattacker\n:\ngetWeapon\n()\n\n\n  \npsf\n(\n\"%s attacks %s with %s for %d HP\"\n,\n \n  \nattacker\n:\ngetName\n(),\n\n  \nattacked\n:\ngetName\n(),\n\n  \nweapon\n:\ngetName\n(),\n\n  \nweapon\n:\ngetAttack\n())\n\n\n  \n--Specialized for Mage type\n\n  \nif\n \nattacker\n:\ninstanceOf\n(\nMage\n)\n \nthen\n\n    \npsf\n(\n\"%s now has %d MP\"\n,\n \n    \nattacker\n:\ngetName\n(),\n\n    \nattacker\n:\ngetMana\n())\n\n  \nend\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nIn the method above, we are getting the \"attack\" status after an \nattack\n method has been called in battle. Since a \nMage\n has an extra \nmana\n property, we need to treat it a little differently. We can use the \ninstanceOf\n method to do a type check (in this case for a \nMage\n type) and then add our logic as needed. In this case printing out the remaining \nmana\n.\n\n\nBattle Methods\n\n\nThe \"battle\" itself takes place in a couple of rounds. We actually only use two methods through the entire thing, those being \nattack\n and \nheal\n.\n\n\nThe majority of the methods are used to print out the results after each method is called.\n\n\nattack\n\n\nThe default \nattack\n method is defined in our base \nCharacter\n class. It looks like this:\n\n\n...\n\n\n\nfunction\n \nCharacter\n:\nattack\n(\ncharacter\n)\n\n  \ncharacter\n:\nhit\n(\nself\n.\nweapon\n:\ngetAttack\n())\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nThe method is called like so:\n\n\n<\nattacker\n>\n:\nattack\n(\n<\nattacked\n>\n)\n\n\n\n\n\n\nIn our \"battle\" code it ends up like this, depending on whose doing the attacking:\n\n\n...\n\n\n\nhero\n:\nattack\n(\nboss\n)\n\n\n\n...\n\n\n\n\n\n\nThe \nMage\n character class is a little different to facilitate its \nmana\n property. The default \nattack\n method is overidden, and looks like so in the \nMage\n class:\n\n\n...\n\n\n\n--override parent method\n\n\nfunction\n \nMage\n:\nattack\n(\ncharacter\n)\n\n  \nlocal\n \nweapon\n \n=\n \nself\n:\ngetWeapon\n()\n\n  \nself\n:\nuseMana\n(\nweapon\n:\ngetManaCost\n())\n\n\n  \n--Call parent attack method\n\n  \nMage\n.\nsuper\n.\nattack\n(\nself\n,\n \ncharacter\n)\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nIn the overridden method, we want to deplete some of the mages \nmana\n, and then we call the \nMage.super.attack\n method, which does the rest of the work of the default \nCharacter\n \nattack\n method.\n\n\nThe \nattack\n method is still used the same in the \"battle\" code:\n\n\n...\n\n\n\nmage\n:\nattack\n(\nboss\n)\n\n\n\n...\n\n\n\n\n\n\nheal\n\n\nThe \nheal\n method is defined in the base \nCharacter\n class, and looks like so:\n\n\n...\n\n\n\nfunction\n \nCharacter\n:\nheal\n(\namount\n)\n\n  \namount\n \n=\n \nself\n:\ngetHealth\n()\n \n+\n \namount\n\n  \nself\n:\nsetHealth\n(\nmath.min\n(\namount\n,\n \nself\n:\ngetMaxHealth\n()))\n\n\nend\n\n\n\n...\n\n\n\n\n\n\nWe simply call this method in the \"battle\" on the instance we want to heal, along with the \namount\n to heal with:\n\n\n...\n\n\n\nmage\n:\nheal\n(\n20\n)\n\n\n\n...\n\n\n\n\n\n\nThe \"Battle Code\n\n\nIf you'd like to run the full project in Corona, and see the output, \ndownload the demo project\n. The main \"battle\" code is shown below:\n\n\n--#############################################################################\n\n\n--# Classy OOP - Mock Battle Demo\n\n\n--# (c)2018 C. Byerley (develephant)\n\n\n--#############################################################################\n\n\nlocal\n \nsf\n \n=\n \nstring.format\n\n\nlocal\n \nrep\n \n=\n \nstring.rep\n\n\n--#############################################################################\n\n\n--# Character + Weapon Classes\n\n\n--#############################################################################\n\n\nlocal\n \nMage\n    \n=\n \nrequire\n(\n\"classes.Mage\"\n)\n\n\nlocal\n \nWarrior\n \n=\n \nrequire\n(\n\"classes.Warrior\"\n)\n\n\nlocal\n \nWand\n    \n=\n \nrequire\n(\n\"classes.Wand\"\n)\n\n\nlocal\n \nMelee\n   \n=\n \nrequire\n(\n\"classes.Melee\"\n)\n\n\n--#############################################################################\n\n\n--# Create Weapon Instances\n\n\n--#############################################################################\n\n\nlocal\n \nsword\n \n=\n \nMelee\n:\nnew\n(\n'Titan Blade'\n,\n \n'sword'\n,\n \n30\n)\n\n\nlocal\n \naxe\n   \n=\n \nMelee\n:\nnew\n(\n'Gilded Axe'\n,\n \n'battle axe'\n,\n \n50\n)\n\n\nlocal\n \nwand\n  \n=\n \nWand\n:\nnew\n(\n'Enchanted Stick'\n,\n \n'wand'\n,\n \n10\n)\n\n\n--#############################################################################\n\n\n--# Create Character Instances\n\n\n--#############################################################################\n\n\nlocal\n \nhero\n  \n=\n \nWarrior\n:\nnew\n(\n'Thundar'\n,\n \n'warrior'\n,\n \n100\n,\n \n100\n,\n \nsword\n)\n\n\nlocal\n \nboss\n  \n=\n \nWarrior\n:\nnew\n(\n'Azarak'\n,\n \n'warrior'\n,\n \n200\n,\n \n200\n,\n \naxe\n)\n\n\nlocal\n \nmage\n  \n=\n \nMage\n:\nnew\n(\n'Chalice'\n,\n \n'mage'\n,\n \n60\n,\n \n60\n,\n \nwand\n,\n \n100\n,\n \n100\n)\n\n\n--#############################################################################\n\n\n--# Battle Messaging / Utilities\n\n\n--#############################################################################\n\n\nlocal\n \npsf\n \n=\n \nfunction\n(\nstr\n,\n \n...)\n \nprint\n(\nsf\n(\nstr\n,\n \n...))\n \nend\n\n\nlocal\n \npblock\n \n=\n \nfunction\n(\nstr\n)\n\n  \nprint\n(\nrep\n(\n\"#\"\n,\n \n80\n))\n\n  \nprint\n(\n\"# \"\n..\nstr\n)\n\n  \nprint\n(\nrep\n(\n\"#\"\n,\n \n80\n))\n\n\nend\n\n\n\nlocal\n \nfunction\n \nwarriorPresence\n(\nwarrior\n)\n\n  \npsf\n(\n\"The %s %s has appeared with %d HP\"\n,\n \n  \nwarrior\n:\ngetType\n(),\n \n  \nwarrior\n:\ngetName\n(),\n \n  \nwarrior\n:\ngetHealth\n())\n\n\n  \nlocal\n \nweapon\n \n=\n \nwarrior\n:\ngetWeapon\n()\n\n\n  \npsf\n(\n\"%s welds %s, a %s with %d attack\"\n,\n \n  \nwarrior\n:\ngetName\n(),\n\n  \nweapon\n:\ngetName\n(),\n \n  \nweapon\n:\ngetType\n(),\n \n  \nweapon\n:\ngetAttack\n())\n\n\nend\n\n\n\nlocal\n \nfunction\n \nmagePresence\n(\nmage\n)\n\n  \npsf\n(\n\"The %s %s has appeared with %d HP and %d MP\"\n,\n \n  \nmage\n:\ngetType\n(),\n \n  \nmage\n:\ngetName\n(),\n \n  \nmage\n:\ngetHealth\n(),\n\n  \nmage\n:\ngetMana\n())\n\n\n  \nlocal\n \nweapon\n \n=\n \nmage\n:\ngetWeapon\n()\n\n\n  \npsf\n(\n\"%s welds %s, a %s with %d attack\"\n,\n \n  \nmage\n:\ngetName\n(),\n\n  \nweapon\n:\ngetName\n(),\n \n  \nweapon\n:\ngetType\n(),\n \n  \nweapon\n:\ngetAttack\n())\n\n\nend\n\n\n\nlocal\n \nfunction\n \nattackStatus\n(\nattacker\n,\n \nattacked\n)\n\n  \nlocal\n \nweapon\n \n=\n \nattacker\n:\ngetWeapon\n()\n\n\n  \npsf\n(\n\"%s attacks %s with %s for %d HP\"\n,\n \n  \nattacker\n:\ngetName\n(),\n\n  \nattacked\n:\ngetName\n(),\n\n  \nweapon\n:\ngetName\n(),\n\n  \nweapon\n:\ngetAttack\n())\n\n\n  \n--Specialized for Mage type\n\n  \nif\n \nattacker\n:\ninstanceOf\n(\nMage\n)\n \nthen\n\n    \npsf\n(\n\"%s now has %d MP\"\n,\n \n    \nattacker\n:\ngetName\n(),\n\n    \nattacker\n:\ngetMana\n())\n\n  \nend\n\n\nend\n\n\n\nlocal\n \nfunction\n \nhealStatus\n(\ncharacter\n,\n \namount\n)\n\n  \npsf\n(\n\"%s heals for %d HP, now has %d HP.\"\n,\n \n  \ncharacter\n:\ngetName\n(),\n\n  \namount\n,\n\n  \ncharacter\n:\ngetHealth\n())\n\n\nend\n\n\n\nlocal\n \nfunction\n \nisDead\n(\ncharacter\n)\n\n  \nif\n \ncharacter\n:\nisDead\n()\n \nthen\n\n    \npsf\n(\n\"%s has been killed!\"\n,\n \ncharacter\n:\ngetName\n())\n\n  \nend\n\n\nend\n\n\n\nlocal\n \nfunction\n \nhealthStatus\n(\ncharacter\n)\n\n  \npsf\n(\n\"%s now has %d HP\"\n,\n \n  \ncharacter\n:\ngetName\n(),\n\n  \ncharacter\n:\ngetHealth\n())\n\n\n  \nisDead\n(\ncharacter\n)\n\n\nend\n\n\n\npblock\n(\n\"Classy OOP - Mock Battle Demo\"\n)\n\n\n\n--#############################################################################\n\n\n--# Battle Start Introductions\n\n\n--#############################################################################\n\n\npblock\n(\n\"Battle Start\"\n)\n\n\n\n--# Hero (warrior)\n\n\nwarriorPresence\n(\nhero\n)\n\n\n--# Mage\n\n\nmagePresence\n(\nmage\n)\n\n\n--# Boss (warrior)\n\n\nwarriorPresence\n(\nboss\n)\n\n\n\n--#############################################################################\n\n\n--# Attack Round One\n\n\n--#############################################################################\n\n\npblock\n(\n\"Round One\"\n)\n\n\n\n--# Mage attacks Boss\n\n\nmage\n:\nattack\n(\nboss\n)\n\n\nattackStatus\n(\nmage\n,\n \nboss\n)\n\n\nhealthStatus\n(\nboss\n)\n\n\n\n--# Hero attacks Boss\n\n\nhero\n:\nattack\n(\nboss\n)\n\n\nattackStatus\n(\nhero\n,\n \nboss\n)\n\n\nhealthStatus\n(\nboss\n)\n\n\n\n--# Boss attacks Mage\n\n\nboss\n:\nattack\n(\nmage\n)\n\n\nattackStatus\n(\nboss\n,\n \nmage\n)\n\n\nhealthStatus\n(\nmage\n)\n\n\n\n--# Boss attacks Hero\n\n\nboss\n:\nattack\n(\nhero\n)\n\n\nattackStatus\n(\nboss\n,\n \nhero\n)\n\n\nhealthStatus\n(\nhero\n)\n\n\n\n--#############################################################################\n\n\n--# Attack Round Two\n\n\n--#############################################################################\n\n\npblock\n(\n\"Round Two\"\n)\n\n\n\n--# Mage attacks Boss\n\n\nmage\n:\nattack\n(\nboss\n)\n\n\nattackStatus\n(\nmage\n,\n \nboss\n)\n\n\nhealthStatus\n(\nboss\n)\n\n\n\n--# Heal Mage\n\n\nmage\n:\nheal\n(\n20\n)\n\n\nhealStatus\n(\nmage\n,\n \n20\n)\n\n\n\n--# Hero attacks Boss\n\n\nhero\n:\nattack\n(\nboss\n)\n\n\nattackStatus\n(\nhero\n,\n \nboss\n)\n\n\nhealthStatus\n(\nboss\n)\n\n\n\n--# Boss attacks Hero\n\n\nboss\n:\nattack\n(\nhero\n)\n\n\nattackStatus\n(\nboss\n,\n \nhero\n)\n\n\nhealthStatus\n(\nhero\n)\n\n\n\n--# Boss attacks Mage\n\n\nboss\n:\nattack\n(\nmage\n)\n\n\nattackStatus\n(\nboss\n,\n \nmage\n)\n\n\nhealthStatus\n(\nmage\n)\n\n\n\npblock\n(\n\"Battle Done\"\n)\n\n\n\n--#############################################################################\n\n\n--# UI\n\n\n--#############################################################################\n\n\ndisplay\n.\nnewText\n({\n\n  \ntext\n \n=\n \n\"See console for demo output.\"\n,\n\n  \nx\n \n=\n \ndisplay\n.\ncontentCenterX\n,\n\n  \ny\n \n=\n \ndisplay\n.\ncontentCenterY\n,\n\n  \nfont\n \n=\n \nnative\n.\nsystemFontBold\n\n\n})",
            "title": "Mock Battle"
        },
        {
            "location": "/tutorial/battle/#code-setup",
            "text": "At the start of the file we localize a few  string  methods for output. You might notice we don't need to  require  the  Classy OOP  plugin here. As a matter of fact we've only needed the plugin in a couple of the code class pages.",
            "title": "Code Setup"
        },
        {
            "location": "/tutorial/battle/#classes",
            "text": "",
            "title": "Classes"
        },
        {
            "location": "/tutorial/battle/#characters",
            "text": "Now we bring in the  Character  classes that we created:  ...  local   Mage      =   require ( \"classes.Mage\" )  local   Warrior   =   require ( \"classes.Warrior\" )  ...   You should notice that we don't need to bring in the base  Character  class file. We only need the subclasses, as they already have references to the base  Character  class.",
            "title": "Characters"
        },
        {
            "location": "/tutorial/battle/#weapons",
            "text": "We follow up with the  Weapon  classes:  ...  local   Wand      =   require ( \"classes.Wand\" )  local   Melee     =   require ( \"classes.Melee\" )  ...   Again, we don't need the base  Weapon  class file. We only need the subclasses.",
            "title": "Weapons"
        },
        {
            "location": "/tutorial/battle/#instances",
            "text": "",
            "title": "Instances"
        },
        {
            "location": "/tutorial/battle/#weapons_1",
            "text": "Now let's create our weapon instances. We are doing this first so that we can \"equip\" them on our upcoming character instances. We could of course equip them after the fact using the character class  setWeapon  method, but this is just as well.  ...  local   sword   =   Melee : new ( 'Titan Blade' ,   'sword' ,   30 )  local   axe     =   Melee : new ( 'Gilded Axe' ,   'battle axe' ,   50 )  local   wand    =   Wand : new ( 'Enchanted Stick' ,   'wand' ,   10 )  ...   Above we are creating two  Melee  class weapons, and one  Wand . The  Weapon  base class takes a  name ,  isType , and  attack  argument, which we pass for each of the instaces we created.  We now have three weapon instances that we can \"equip\" on our characters.",
            "title": "Weapons"
        },
        {
            "location": "/tutorial/battle/#characters_1",
            "text": "Building the character instances is very much the same as our weapons:  ...  local   hero    =   Warrior : new ( 'Thundar' ,   'warrior' ,   100 ,   100 ,   sword )  local   boss    =   Warrior : new ( 'Azarak' ,   'warrior' ,   200 ,   200 ,   axe )  local   mage    =   Mage : new ( 'Chalice' ,   'mage' ,   60 ,   60 ,   wand ,   100 ,   100 )  ...   Above we have created two warriors, one a hero and the other a boss (baddie). We also have a mage along with us.  The  Warrior  class needs a  name ,  isType ,  health ,  maxHealth , and  weapon  argument passed to it. The  Mage  is a special subclass that also takes a  mana  and  maxMana  argument along with the others.  As you can see, we pass the previously generated weapon instances directly to the character instances.",
            "title": "Characters"
        },
        {
            "location": "/tutorial/battle/#output-methods",
            "text": "After our charactes and weapons there are a handful of utility methods to help print out the \"battle\" status as it takes place. These should be fairly self-explanatory.  There is one method that should be pointed out:  ...  local   function   attackStatus ( attacker ,   attacked ) \n   local   weapon   =   attacker : getWeapon () \n\n   psf ( \"%s attacks %s with %s for %d HP\" ,  \n   attacker : getName (), \n   attacked : getName (), \n   weapon : getName (), \n   weapon : getAttack ()) \n\n   --Specialized for Mage type \n   if   attacker : instanceOf ( Mage )   then \n     psf ( \"%s now has %d MP\" ,  \n     attacker : getName (), \n     attacker : getMana ()) \n   end  end  ...   In the method above, we are getting the \"attack\" status after an  attack  method has been called in battle. Since a  Mage  has an extra  mana  property, we need to treat it a little differently. We can use the  instanceOf  method to do a type check (in this case for a  Mage  type) and then add our logic as needed. In this case printing out the remaining  mana .",
            "title": "Output Methods"
        },
        {
            "location": "/tutorial/battle/#battle-methods",
            "text": "The \"battle\" itself takes place in a couple of rounds. We actually only use two methods through the entire thing, those being  attack  and  heal .  The majority of the methods are used to print out the results after each method is called.",
            "title": "Battle Methods"
        },
        {
            "location": "/tutorial/battle/#attack",
            "text": "The default  attack  method is defined in our base  Character  class. It looks like this:  ...  function   Character : attack ( character ) \n   character : hit ( self . weapon : getAttack ())  end  ...   The method is called like so:  < attacker > : attack ( < attacked > )   In our \"battle\" code it ends up like this, depending on whose doing the attacking:  ...  hero : attack ( boss )  ...   The  Mage  character class is a little different to facilitate its  mana  property. The default  attack  method is overidden, and looks like so in the  Mage  class:  ...  --override parent method  function   Mage : attack ( character ) \n   local   weapon   =   self : getWeapon () \n   self : useMana ( weapon : getManaCost ()) \n\n   --Call parent attack method \n   Mage . super . attack ( self ,   character )  end  ...   In the overridden method, we want to deplete some of the mages  mana , and then we call the  Mage.super.attack  method, which does the rest of the work of the default  Character   attack  method.  The  attack  method is still used the same in the \"battle\" code:  ...  mage : attack ( boss )  ...",
            "title": "attack"
        },
        {
            "location": "/tutorial/battle/#heal",
            "text": "The  heal  method is defined in the base  Character  class, and looks like so:  ...  function   Character : heal ( amount ) \n   amount   =   self : getHealth ()   +   amount \n   self : setHealth ( math.min ( amount ,   self : getMaxHealth ()))  end  ...   We simply call this method in the \"battle\" on the instance we want to heal, along with the  amount  to heal with:  ...  mage : heal ( 20 )  ...",
            "title": "heal"
        },
        {
            "location": "/tutorial/battle/#the-battle-code",
            "text": "If you'd like to run the full project in Corona, and see the output,  download the demo project . The main \"battle\" code is shown below:  --#############################################################################  --# Classy OOP - Mock Battle Demo  --# (c)2018 C. Byerley (develephant)  --#############################################################################  local   sf   =   string.format  local   rep   =   string.rep  --#############################################################################  --# Character + Weapon Classes  --#############################################################################  local   Mage      =   require ( \"classes.Mage\" )  local   Warrior   =   require ( \"classes.Warrior\" )  local   Wand      =   require ( \"classes.Wand\" )  local   Melee     =   require ( \"classes.Melee\" )  --#############################################################################  --# Create Weapon Instances  --#############################################################################  local   sword   =   Melee : new ( 'Titan Blade' ,   'sword' ,   30 )  local   axe     =   Melee : new ( 'Gilded Axe' ,   'battle axe' ,   50 )  local   wand    =   Wand : new ( 'Enchanted Stick' ,   'wand' ,   10 )  --#############################################################################  --# Create Character Instances  --#############################################################################  local   hero    =   Warrior : new ( 'Thundar' ,   'warrior' ,   100 ,   100 ,   sword )  local   boss    =   Warrior : new ( 'Azarak' ,   'warrior' ,   200 ,   200 ,   axe )  local   mage    =   Mage : new ( 'Chalice' ,   'mage' ,   60 ,   60 ,   wand ,   100 ,   100 )  --#############################################################################  --# Battle Messaging / Utilities  --#############################################################################  local   psf   =   function ( str ,   ...)   print ( sf ( str ,   ...))   end  local   pblock   =   function ( str ) \n   print ( rep ( \"#\" ,   80 )) \n   print ( \"# \" .. str ) \n   print ( rep ( \"#\" ,   80 ))  end  local   function   warriorPresence ( warrior ) \n   psf ( \"The %s %s has appeared with %d HP\" ,  \n   warrior : getType (),  \n   warrior : getName (),  \n   warrior : getHealth ()) \n\n   local   weapon   =   warrior : getWeapon () \n\n   psf ( \"%s welds %s, a %s with %d attack\" ,  \n   warrior : getName (), \n   weapon : getName (),  \n   weapon : getType (),  \n   weapon : getAttack ())  end  local   function   magePresence ( mage ) \n   psf ( \"The %s %s has appeared with %d HP and %d MP\" ,  \n   mage : getType (),  \n   mage : getName (),  \n   mage : getHealth (), \n   mage : getMana ()) \n\n   local   weapon   =   mage : getWeapon () \n\n   psf ( \"%s welds %s, a %s with %d attack\" ,  \n   mage : getName (), \n   weapon : getName (),  \n   weapon : getType (),  \n   weapon : getAttack ())  end  local   function   attackStatus ( attacker ,   attacked ) \n   local   weapon   =   attacker : getWeapon () \n\n   psf ( \"%s attacks %s with %s for %d HP\" ,  \n   attacker : getName (), \n   attacked : getName (), \n   weapon : getName (), \n   weapon : getAttack ()) \n\n   --Specialized for Mage type \n   if   attacker : instanceOf ( Mage )   then \n     psf ( \"%s now has %d MP\" ,  \n     attacker : getName (), \n     attacker : getMana ()) \n   end  end  local   function   healStatus ( character ,   amount ) \n   psf ( \"%s heals for %d HP, now has %d HP.\" ,  \n   character : getName (), \n   amount , \n   character : getHealth ())  end  local   function   isDead ( character ) \n   if   character : isDead ()   then \n     psf ( \"%s has been killed!\" ,   character : getName ()) \n   end  end  local   function   healthStatus ( character ) \n   psf ( \"%s now has %d HP\" ,  \n   character : getName (), \n   character : getHealth ()) \n\n   isDead ( character )  end  pblock ( \"Classy OOP - Mock Battle Demo\" )  --#############################################################################  --# Battle Start Introductions  --#############################################################################  pblock ( \"Battle Start\" )  --# Hero (warrior)  warriorPresence ( hero )  --# Mage  magePresence ( mage )  --# Boss (warrior)  warriorPresence ( boss )  --#############################################################################  --# Attack Round One  --#############################################################################  pblock ( \"Round One\" )  --# Mage attacks Boss  mage : attack ( boss )  attackStatus ( mage ,   boss )  healthStatus ( boss )  --# Hero attacks Boss  hero : attack ( boss )  attackStatus ( hero ,   boss )  healthStatus ( boss )  --# Boss attacks Mage  boss : attack ( mage )  attackStatus ( boss ,   mage )  healthStatus ( mage )  --# Boss attacks Hero  boss : attack ( hero )  attackStatus ( boss ,   hero )  healthStatus ( hero )  --#############################################################################  --# Attack Round Two  --#############################################################################  pblock ( \"Round Two\" )  --# Mage attacks Boss  mage : attack ( boss )  attackStatus ( mage ,   boss )  healthStatus ( boss )  --# Heal Mage  mage : heal ( 20 )  healStatus ( mage ,   20 )  --# Hero attacks Boss  hero : attack ( boss )  attackStatus ( hero ,   boss )  healthStatus ( boss )  --# Boss attacks Hero  boss : attack ( hero )  attackStatus ( boss ,   hero )  healthStatus ( hero )  --# Boss attacks Mage  boss : attack ( mage )  attackStatus ( boss ,   mage )  healthStatus ( mage )  pblock ( \"Battle Done\" )  --#############################################################################  --# UI  --#############################################################################  display . newText ({ \n   text   =   \"See console for demo output.\" , \n   x   =   display . contentCenterX , \n   y   =   display . contentCenterY , \n   font   =   native . systemFontBold  })",
            "title": "The \"Battle Code"
        },
        {
            "location": "/demo/",
            "text": "Click here to download\n the full Corona demo project with classes.",
            "title": "Demo"
        },
        {
            "location": "/about/",
            "text": "Classy OOP Plugin\n\n\n\nCode and documentation \u00a92018 C. Byerley (\ndevelephant\n)",
            "title": "About"
        }
    ]
}